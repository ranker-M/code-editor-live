{"ast":null,"code":"import { Facet, combineConfig, StateField } from '@codemirror/state';\nimport { syntaxTree } from '@codemirror/language';\nimport { EditorView, Decoration } from '@codemirror/view';\nimport { NodeProp } from '@lezer/common';\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-matchingBracket\": {\n    backgroundColor: \"#328c8252\"\n  },\n  \".cm-nonmatchingBracket\": {\n    backgroundColor: \"#bb555544\"\n  }\n});\nconst DefaultScanDist = 10000,\n      DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = /*@__PURE__*/Facet.define({\n  combine(configs) {\n    return combineConfig(configs, {\n      afterCursor: true,\n      brackets: DefaultBrackets,\n      maxScanDistance: DefaultScanDist\n    });\n  }\n\n});\nconst matchingMark = /*@__PURE__*/Decoration.mark({\n  class: \"cm-matchingBracket\"\n}),\n      nonmatchingMark = /*@__PURE__*/Decoration.mark({\n  class: \"cm-nonmatchingBracket\"\n});\nconst bracketMatchingState = /*@__PURE__*/StateField.define({\n  create() {\n    return Decoration.none;\n  },\n\n  update(deco, tr) {\n    if (!tr.docChanged && !tr.selection) return deco;\n    let decorations = [];\n    let config = tr.state.facet(bracketMatchingConfig);\n\n    for (let range of tr.state.selection.ranges) {\n      if (!range.empty) continue;\n      let match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));\n      if (!match) continue;\n      let mark = match.matched ? matchingMark : nonmatchingMark;\n      decorations.push(mark.range(match.start.from, match.start.to));\n      if (match.end) decorations.push(mark.range(match.end.from, match.end.to));\n    }\n\n    return Decoration.set(decorations, true);\n  },\n\n  provide: f => EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [bracketMatchingState, baseTheme];\n/**\nCreate an extension that enables bracket matching. Whenever the\ncursor is next to a bracket, that bracket and the one it matches\nare highlighted. Or, when no matching bracket is found, another\nhighlighting style is used to indicate this.\n*/\n\nfunction bracketMatching() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return [bracketMatchingConfig.of(config), bracketMatchingUnique];\n}\n\nfunction matchingNodes(node, dir, brackets) {\n  let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);\n  if (byProp) return byProp;\n\n  if (node.name.length == 1) {\n    let index = brackets.indexOf(node.name);\n    if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [brackets[index + dir]];\n  }\n\n  return null;\n}\n/**\nFind the matching bracket for the token at `pos`, scanning\ndirection `dir`. Only the `brackets` and `maxScanDistance`\nproperties are used from `config`, if given. Returns null if no\nbracket was found at `pos`, or a match result otherwise.\n*/\n\n\nfunction matchBrackets(state, pos, dir) {\n  let config = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let maxScanDistance = config.maxScanDistance || DefaultScanDist,\n      brackets = config.brackets || DefaultBrackets;\n  let tree = syntaxTree(state),\n      node = tree.resolveInner(pos, dir);\n\n  for (let cur = node; cur; cur = cur.parent) {\n    let matches = matchingNodes(cur.type, dir, brackets);\n    if (matches && cur.from < cur.to) return matchMarkedBrackets(state, pos, dir, cur, matches, brackets);\n  }\n\n  return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);\n}\n\nfunction matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {\n  let parent = token.parent,\n      firstToken = {\n    from: token.from,\n    to: token.to\n  };\n  let depth = 0,\n      cursor = parent === null || parent === void 0 ? void 0 : parent.cursor;\n  if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {\n    if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n      if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {\n        return {\n          start: firstToken,\n          end: {\n            from: cursor.from,\n            to: cursor.to\n          },\n          matched: true\n        };\n      } else if (matchingNodes(cursor.type, dir, brackets)) {\n        depth++;\n      } else if (matchingNodes(cursor.type, -dir, brackets)) {\n        depth--;\n        if (depth == 0) return {\n          start: firstToken,\n          end: cursor.from == cursor.to ? undefined : {\n            from: cursor.from,\n            to: cursor.to\n          },\n          matched: false\n        };\n      }\n    }\n  } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n  return {\n    start: firstToken,\n    matched: false\n  };\n}\n\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n  let bracket = brackets.indexOf(startCh);\n  if (bracket < 0 || bracket % 2 == 0 != dir > 0) return null;\n  let startToken = {\n    from: dir < 0 ? pos - 1 : pos,\n    to: dir > 0 ? pos + 1 : pos\n  };\n  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0),\n      depth = 0;\n\n  for (let distance = 0; !iter.next().done && distance <= maxScanDistance;) {\n    let text = iter.value;\n    if (dir < 0) distance += text.length;\n    let basePos = pos + distance * dir;\n\n    for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\n      let found = brackets.indexOf(text[pos]);\n      if (found < 0 || tree.resolve(basePos + pos, 1).type != tokenType) continue;\n\n      if (found % 2 == 0 == dir > 0) {\n        depth++;\n      } else if (depth == 1) {\n        // Closing\n        return {\n          start: startToken,\n          end: {\n            from: basePos + pos,\n            to: basePos + pos + 1\n          },\n          matched: found >> 1 == bracket >> 1\n        };\n      } else {\n        depth--;\n      }\n    }\n\n    if (dir > 0) distance += text.length;\n  }\n\n  return iter.done ? {\n    start: startToken,\n    matched: false\n  } : null;\n}\n\nexport { bracketMatching, matchBrackets };","map":{"version":3,"sources":["C:/Users/pc/Desktop/live-code-editor/client/node_modules/@codemirror/matchbrackets/dist/index.js"],"names":["Facet","combineConfig","StateField","syntaxTree","EditorView","Decoration","NodeProp","baseTheme","backgroundColor","DefaultScanDist","DefaultBrackets","bracketMatchingConfig","define","combine","configs","afterCursor","brackets","maxScanDistance","matchingMark","mark","class","nonmatchingMark","bracketMatchingState","create","none","update","deco","tr","docChanged","selection","decorations","config","state","facet","range","ranges","empty","match","matchBrackets","head","doc","length","matched","push","start","from","to","end","set","provide","f","bracketMatchingUnique","bracketMatching","of","matchingNodes","node","dir","byProp","prop","openedBy","closedBy","name","index","indexOf","pos","tree","resolveInner","cur","parent","matches","type","matchMarkedBrackets","matchPlainBrackets","_state","_pos","token","matching","firstToken","depth","cursor","childBefore","childAfter","undefined","prevSibling","nextSibling","tokenType","startCh","sliceDoc","bracket","startToken","iter","iterRange","distance","next","done","text","value","basePos","found","resolve"],"mappings":"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","sourcesContent":["import { Facet, combineConfig, StateField } from '@codemirror/state';\nimport { syntaxTree } from '@codemirror/language';\nimport { EditorView, Decoration } from '@codemirror/view';\nimport { NodeProp } from '@lezer/common';\n\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-matchingBracket\": { backgroundColor: \"#328c8252\" },\n    \".cm-nonmatchingBracket\": { backgroundColor: \"#bb555544\" }\n});\nconst DefaultScanDist = 10000, DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            afterCursor: true,\n            brackets: DefaultBrackets,\n            maxScanDistance: DefaultScanDist\n        });\n    }\n});\nconst matchingMark = /*@__PURE__*/Decoration.mark({ class: \"cm-matchingBracket\" }), nonmatchingMark = /*@__PURE__*/Decoration.mark({ class: \"cm-nonmatchingBracket\" });\nconst bracketMatchingState = /*@__PURE__*/StateField.define({\n    create() { return Decoration.none; },\n    update(deco, tr) {\n        if (!tr.docChanged && !tr.selection)\n            return deco;\n        let decorations = [];\n        let config = tr.state.facet(bracketMatchingConfig);\n        for (let range of tr.state.selection.ranges) {\n            if (!range.empty)\n                continue;\n            let match = matchBrackets(tr.state, range.head, -1, config)\n                || (range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config))\n                || (config.afterCursor &&\n                    (matchBrackets(tr.state, range.head, 1, config) ||\n                        (range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config))));\n            if (!match)\n                continue;\n            let mark = match.matched ? matchingMark : nonmatchingMark;\n            decorations.push(mark.range(match.start.from, match.start.to));\n            if (match.end)\n                decorations.push(mark.range(match.end.from, match.end.to));\n        }\n        return Decoration.set(decorations, true);\n    },\n    provide: f => EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [\n    bracketMatchingState,\n    baseTheme\n];\n/**\nCreate an extension that enables bracket matching. Whenever the\ncursor is next to a bracket, that bracket and the one it matches\nare highlighted. Or, when no matching bracket is found, another\nhighlighting style is used to indicate this.\n*/\nfunction bracketMatching(config = {}) {\n    return [bracketMatchingConfig.of(config), bracketMatchingUnique];\n}\nfunction matchingNodes(node, dir, brackets) {\n    let byProp = node.prop(dir < 0 ? NodeProp.openedBy : NodeProp.closedBy);\n    if (byProp)\n        return byProp;\n    if (node.name.length == 1) {\n        let index = brackets.indexOf(node.name);\n        if (index > -1 && index % 2 == (dir < 0 ? 1 : 0))\n            return [brackets[index + dir]];\n    }\n    return null;\n}\n/**\nFind the matching bracket for the token at `pos`, scanning\ndirection `dir`. Only the `brackets` and `maxScanDistance`\nproperties are used from `config`, if given. Returns null if no\nbracket was found at `pos`, or a match result otherwise.\n*/\nfunction matchBrackets(state, pos, dir, config = {}) {\n    let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;\n    let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);\n    for (let cur = node; cur; cur = cur.parent) {\n        let matches = matchingNodes(cur.type, dir, brackets);\n        if (matches && cur.from < cur.to)\n            return matchMarkedBrackets(state, pos, dir, cur, matches, brackets);\n    }\n    return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, matching, brackets) {\n    let parent = token.parent, firstToken = { from: token.from, to: token.to };\n    let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor;\n    if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))\n        do {\n            if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n                if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {\n                    return { start: firstToken, end: { from: cursor.from, to: cursor.to }, matched: true };\n                }\n                else if (matchingNodes(cursor.type, dir, brackets)) {\n                    depth++;\n                }\n                else if (matchingNodes(cursor.type, -dir, brackets)) {\n                    depth--;\n                    if (depth == 0)\n                        return {\n                            start: firstToken,\n                            end: cursor.from == cursor.to ? undefined : { from: cursor.from, to: cursor.to },\n                            matched: false\n                        };\n                }\n            }\n        } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n    return { start: firstToken, matched: false };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n    let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n    let bracket = brackets.indexOf(startCh);\n    if (bracket < 0 || (bracket % 2 == 0) != (dir > 0))\n        return null;\n    let startToken = { from: dir < 0 ? pos - 1 : pos, to: dir > 0 ? pos + 1 : pos };\n    let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0), depth = 0;\n    for (let distance = 0; !(iter.next()).done && distance <= maxScanDistance;) {\n        let text = iter.value;\n        if (dir < 0)\n            distance += text.length;\n        let basePos = pos + distance * dir;\n        for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\n            let found = brackets.indexOf(text[pos]);\n            if (found < 0 || tree.resolve(basePos + pos, 1).type != tokenType)\n                continue;\n            if ((found % 2 == 0) == (dir > 0)) {\n                depth++;\n            }\n            else if (depth == 1) { // Closing\n                return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found >> 1) == (bracket >> 1) };\n            }\n            else {\n                depth--;\n            }\n        }\n        if (dir > 0)\n            distance += text.length;\n    }\n    return iter.done ? { start: startToken, matched: false } : null;\n}\n\nexport { bracketMatching, matchBrackets };\n"]},"metadata":{},"sourceType":"module"}