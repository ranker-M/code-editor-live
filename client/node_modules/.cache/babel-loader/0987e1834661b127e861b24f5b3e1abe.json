{"ast":null,"code":"import { parser } from '@lezer/xml';\nimport { syntaxTree, LRLanguage, indentNodeProp, foldNodeProp, LanguageSupport } from '@codemirror/language';\nimport { styleTags, tags } from '@codemirror/highlight';\n\nfunction tagName(doc, tag) {\n  let name = tag && tag.getChild(\"TagName\");\n  return name ? doc.sliceString(name.from, name.to) : \"\";\n}\n\nfunction elementName(doc, tree) {\n  let tag = tree && tree.firstChild;\n  return !tag || tag.name != \"OpenTag\" ? \"\" : tagName(doc, tag);\n}\n\nfunction attrName(doc, tag, pos) {\n  let attr = tag && tag.getChildren(\"Attribute\").find(a => a.from <= pos && a.to >= pos);\n  let name = attr && attr.getChild(\"AttributeName\");\n  return name ? doc.sliceString(name.from, name.to) : \"\";\n}\n\nfunction findParentElement(tree) {\n  for (let cur = tree && tree.parent; cur; cur = cur.parent) if (cur.name == \"Element\") return cur;\n\n  return null;\n}\n\nfunction findLocation(state, pos) {\n  var _a;\n\n  let at = syntaxTree(state).resolveInner(pos, -1),\n      inTag = null;\n\n  for (let cur = at; !inTag && cur.parent; cur = cur.parent) if (cur.name == \"OpenTag\" || cur.name == \"CloseTag\" || cur.name == \"SelfClosingTag\" || cur.name == \"MismatchedCloseTag\") inTag = cur;\n\n  if (inTag && (inTag.to > pos || inTag.lastChild.type.isError)) {\n    let elt = inTag.parent;\n    if (at.name == \"TagName\") return inTag.name == \"CloseTag\" || inTag.name == \"MismatchedCloseTag\" ? {\n      type: \"closeTag\",\n      from: at.from,\n      context: elt\n    } : {\n      type: \"openTag\",\n      from: at.from,\n      context: findParentElement(elt)\n    };\n    if (at.name == \"AttributeName\") return {\n      type: \"attrName\",\n      from: at.from,\n      context: inTag\n    };\n    if (at.name == \"AttributeValue\") return {\n      type: \"attrValue\",\n      from: at.from,\n      context: inTag\n    };\n    let before = at == inTag || at.name == \"Attribute\" ? at.childBefore(pos) : at;\n    if ((before === null || before === void 0 ? void 0 : before.name) == \"StartTag\") return {\n      type: \"openTag\",\n      from: pos,\n      context: findParentElement(elt)\n    };\n    if ((before === null || before === void 0 ? void 0 : before.name) == \"StartCloseTag\" && before.to <= pos) return {\n      type: \"closeTag\",\n      from: pos,\n      context: elt\n    };\n    if ((before === null || before === void 0 ? void 0 : before.name) == \"Is\") return {\n      type: \"attrValue\",\n      from: pos,\n      context: inTag\n    };\n    if (before) return {\n      type: \"attrName\",\n      from: pos,\n      context: inTag\n    };\n    return null;\n  } else if (at.name == \"StartCloseTag\") {\n    return {\n      type: \"closeTag\",\n      from: pos,\n      context: at.parent\n    };\n  }\n\n  while (at.parent && at.to == pos && !((_a = at.lastChild) === null || _a === void 0 ? void 0 : _a.type.isError)) at = at.parent;\n\n  if (at.name == \"Element\" || at.name == \"Text\" || at.name == \"Document\") return {\n    type: \"tag\",\n    from: pos,\n    context: at.name == \"Element\" ? at : findParentElement(at)\n  };\n  return null;\n}\n\nclass Element {\n  constructor(spec, attrs, attrValues) {\n    this.attrs = attrs;\n    this.attrValues = attrValues;\n    this.children = [];\n    this.name = spec.name;\n    this.completion = Object.assign(Object.assign({\n      type: \"type\"\n    }, spec.completion || {}), {\n      label: this.name\n    });\n    this.openCompletion = Object.assign(Object.assign({}, this.completion), {\n      label: \"<\" + this.name\n    });\n    this.closeCompletion = Object.assign(Object.assign({}, this.completion), {\n      label: \"</\" + this.name + \">\",\n      boost: 2\n    });\n    this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), {\n      label: this.name + \">\"\n    });\n    this.text = spec.textContent ? spec.textContent.map(s => ({\n      label: s,\n      type: \"text\"\n    })) : [];\n  }\n\n}\n\nconst Identifier = /^[:\\-\\.\\w\\u00b7-\\uffff]*$/;\n\nfunction attrCompletion(spec) {\n  return Object.assign(Object.assign({\n    type: \"property\"\n  }, spec.completion || {}), {\n    label: spec.name\n  });\n}\n\nfunction valueCompletion(spec) {\n  return typeof spec == \"string\" ? {\n    label: `\"${spec}\"`,\n    type: \"constant\"\n  } : /^\"/.test(spec.label) ? spec : Object.assign(Object.assign({}, spec), {\n    label: `\"${spec.label}\"`\n  });\n}\n\nfunction completeFromSchema(eltSpecs, attrSpecs) {\n  let allAttrs = [],\n      globalAttrs = [];\n  let attrValues = Object.create(null);\n\n  for (let s of attrSpecs) {\n    let completion = attrCompletion(s);\n    allAttrs.push(completion);\n    if (s.global) globalAttrs.push(completion);\n    if (s.values) attrValues[s.name] = s.values.map(valueCompletion);\n  }\n\n  let allElements = [],\n      topElements = [];\n  let byName = Object.create(null);\n\n  for (let s of eltSpecs) {\n    let attrs = globalAttrs,\n        attrVals = attrValues;\n    if (s.attributes) attrs = attrs.concat(s.attributes.map(s => {\n      if (typeof s == \"string\") return allAttrs.find(a => a.label == s) || {\n        label: s,\n        type: \"property\"\n      };\n\n      if (s.values) {\n        if (attrVals == attrValues) attrVals = Object.create(attrVals);\n        attrVals[s.name] = s.values.map(valueCompletion);\n      }\n\n      return attrCompletion(s);\n    }));\n    let elt = new Element(s, attrs, attrVals);\n    byName[elt.name] = elt;\n    allElements.push(elt);\n    if (s.top) topElements.push(elt);\n  }\n\n  if (!topElements.length) topElements = allElements;\n\n  for (let i = 0; i < allElements.length; i++) {\n    let s = eltSpecs[i],\n        elt = allElements[i];\n\n    if (s.children) {\n      for (let ch of s.children) if (byName[ch]) elt.children.push(byName[ch]);\n    } else {\n      elt.children = allElements;\n    }\n  }\n\n  return cx => {\n    var _a;\n\n    let {\n      doc\n    } = cx.state,\n        loc = findLocation(cx.state, cx.pos);\n    if (!loc || loc.type == \"tag\" && !cx.explicit) return null;\n    let {\n      type,\n      from,\n      context\n    } = loc;\n\n    if (type == \"openTag\") {\n      let children = topElements;\n      let parentName = elementName(doc, context);\n\n      if (parentName) {\n        let parent = byName[parentName];\n        children = (parent === null || parent === void 0 ? void 0 : parent.children) || allElements;\n      }\n\n      return {\n        from,\n        options: children.map(ch => ch.completion),\n        span: Identifier\n      };\n    } else if (type == \"closeTag\") {\n      let parentName = elementName(doc, context);\n      return parentName ? {\n        from,\n        to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == \">\" ? 1 : 0),\n        options: [((_a = byName[parentName]) === null || _a === void 0 ? void 0 : _a.closeNameCompletion) || {\n          label: parentName + \">\",\n          type: \"type\"\n        }],\n        span: Identifier\n      } : null;\n    } else if (type == \"attrName\") {\n      let parent = byName[tagName(doc, context)];\n      return {\n        from,\n        options: (parent === null || parent === void 0 ? void 0 : parent.attrs) || globalAttrs,\n        span: Identifier\n      };\n    } else if (type == \"attrValue\") {\n      let attr = attrName(doc, context, from);\n      if (!attr) return null;\n      let parent = byName[tagName(doc, context)];\n      let values = ((parent === null || parent === void 0 ? void 0 : parent.attrValues) || attrValues)[attr];\n      if (!values || !values.length) return null;\n      return {\n        from,\n        to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == '\"' ? 1 : 0),\n        options: values,\n        span: /^\"[^\"]*\"?$/\n      };\n    } else if (type == \"tag\") {\n      let parentName = elementName(doc, context),\n          parent = byName[parentName];\n      let closing = [],\n          last = context && context.lastChild;\n      if (parentName && (!last || last.name != \"CloseTag\" || tagName(doc, last) != parentName)) closing.push(parent ? parent.closeCompletion : {\n        label: \"</\" + parentName + \">\",\n        type: \"type\",\n        boost: 2\n      });\n      let options = closing.concat(((parent === null || parent === void 0 ? void 0 : parent.children) || (context ? allElements : topElements)).map(e => e.openCompletion));\n\n      if (context && (parent === null || parent === void 0 ? void 0 : parent.text.length)) {\n        let openTag = context.firstChild;\n        if (openTag.to > cx.pos - 20 && !/\\S/.test(cx.state.sliceDoc(openTag.to, cx.pos))) options = options.concat(parent.text);\n      }\n\n      return {\n        from,\n        options,\n        span: /^<\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/\n      };\n    } else {\n      return null;\n    }\n  };\n}\n/**\nA language provider based on the [Lezer XML\nparser](https://github.com/lezer-parser/xml), extended with\nhighlighting and indentation information.\n*/\n\n\nconst xmlLanguage = /*@__PURE__*/LRLanguage.define({\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/indentNodeProp.add({\n      Element(context) {\n        let closed = /^\\s*<\\//.test(context.textAfter);\n        return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n      },\n\n      \"OpenTag CloseTag SelfClosingTag\"(context) {\n        return context.column(context.node.from) + context.unit;\n      }\n\n    }), /*@__PURE__*/foldNodeProp.add({\n      Element(subtree) {\n        let first = subtree.firstChild,\n            last = subtree.lastChild;\n        if (!first || first.name != \"OpenTag\") return null;\n        return {\n          from: first.to,\n          to: last.name == \"CloseTag\" ? last.from : subtree.to\n        };\n      }\n\n    }), /*@__PURE__*/styleTags({\n      Text: tags.content,\n      \"StartTag StartCloseTag EndTag SelfCloseEndTag\": tags.angleBracket,\n      TagName: tags.tagName,\n      \"MismatchedCloseTag/Tagname\": [tags.tagName, tags.invalid],\n      AttributeName: tags.attributeName,\n      AttributeValue: tags.attributeValue,\n      Is: tags.definitionOperator,\n      \"EntityReference CharacterReference\": tags.character,\n      Comment: tags.blockComment,\n      ProcessingInst: tags.processingInstruction,\n      DoctypeDecl: tags.documentMeta,\n      Cdata: /*@__PURE__*/tags.special(tags.string)\n    })]\n  }),\n  languageData: {\n    commentTokens: {\n      block: {\n        open: \"<!--\",\n        close: \"-->\"\n      }\n    },\n    indentOnInput: /^\\s*<\\/$/\n  }\n});\n/**\nXML language support. Includes schema-based autocompletion when\nconfigured.\n*/\n\nfunction xml() {\n  let conf = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new LanguageSupport(xmlLanguage, xmlLanguage.data.of({\n    autocomplete: completeFromSchema(conf.elements || [], conf.attributes || [])\n  }));\n}\n\nexport { completeFromSchema, xml, xmlLanguage };","map":{"version":3,"sources":["C:/Users/pc/Desktop/live-code-editor/client/node_modules/@codemirror/lang-xml/dist/index.js"],"names":["parser","syntaxTree","LRLanguage","indentNodeProp","foldNodeProp","LanguageSupport","styleTags","tags","tagName","doc","tag","name","getChild","sliceString","from","to","elementName","tree","firstChild","attrName","pos","attr","getChildren","find","a","findParentElement","cur","parent","findLocation","state","_a","at","resolveInner","inTag","lastChild","type","isError","elt","context","before","childBefore","Element","constructor","spec","attrs","attrValues","children","completion","Object","assign","label","openCompletion","closeCompletion","boost","closeNameCompletion","text","textContent","map","s","Identifier","attrCompletion","valueCompletion","test","completeFromSchema","eltSpecs","attrSpecs","allAttrs","globalAttrs","create","push","global","values","allElements","topElements","byName","attrVals","attributes","concat","top","length","i","ch","cx","loc","explicit","parentName","options","span","closing","last","e","openTag","sliceDoc","xmlLanguage","define","configure","props","add","closed","textAfter","lineIndent","node","unit","column","subtree","first","Text","content","angleBracket","TagName","invalid","AttributeName","attributeName","AttributeValue","attributeValue","Is","definitionOperator","character","Comment","blockComment","ProcessingInst","processingInstruction","DoctypeDecl","documentMeta","Cdata","special","string","languageData","commentTokens","block","open","close","indentOnInput","xml","conf","data","of","autocomplete","elements"],"mappings":"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","sourcesContent":["import { parser } from '@lezer/xml';\nimport { syntaxTree, LRLanguage, indentNodeProp, foldNodeProp, LanguageSupport } from '@codemirror/language';\nimport { styleTags, tags } from '@codemirror/highlight';\n\nfunction tagName(doc, tag) {\n    let name = tag && tag.getChild(\"TagName\");\n    return name ? doc.sliceString(name.from, name.to) : \"\";\n}\nfunction elementName(doc, tree) {\n    let tag = tree && tree.firstChild;\n    return !tag || tag.name != \"OpenTag\" ? \"\" : tagName(doc, tag);\n}\nfunction attrName(doc, tag, pos) {\n    let attr = tag && tag.getChildren(\"Attribute\").find(a => a.from <= pos && a.to >= pos);\n    let name = attr && attr.getChild(\"AttributeName\");\n    return name ? doc.sliceString(name.from, name.to) : \"\";\n}\nfunction findParentElement(tree) {\n    for (let cur = tree && tree.parent; cur; cur = cur.parent)\n        if (cur.name == \"Element\")\n            return cur;\n    return null;\n}\nfunction findLocation(state, pos) {\n    var _a;\n    let at = syntaxTree(state).resolveInner(pos, -1), inTag = null;\n    for (let cur = at; !inTag && cur.parent; cur = cur.parent)\n        if (cur.name == \"OpenTag\" || cur.name == \"CloseTag\" || cur.name == \"SelfClosingTag\" || cur.name == \"MismatchedCloseTag\")\n            inTag = cur;\n    if (inTag && (inTag.to > pos || inTag.lastChild.type.isError)) {\n        let elt = inTag.parent;\n        if (at.name == \"TagName\")\n            return inTag.name == \"CloseTag\" || inTag.name == \"MismatchedCloseTag\"\n                ? { type: \"closeTag\", from: at.from, context: elt }\n                : { type: \"openTag\", from: at.from, context: findParentElement(elt) };\n        if (at.name == \"AttributeName\")\n            return { type: \"attrName\", from: at.from, context: inTag };\n        if (at.name == \"AttributeValue\")\n            return { type: \"attrValue\", from: at.from, context: inTag };\n        let before = at == inTag || at.name == \"Attribute\" ? at.childBefore(pos) : at;\n        if ((before === null || before === void 0 ? void 0 : before.name) == \"StartTag\")\n            return { type: \"openTag\", from: pos, context: findParentElement(elt) };\n        if ((before === null || before === void 0 ? void 0 : before.name) == \"StartCloseTag\" && before.to <= pos)\n            return { type: \"closeTag\", from: pos, context: elt };\n        if ((before === null || before === void 0 ? void 0 : before.name) == \"Is\")\n            return { type: \"attrValue\", from: pos, context: inTag };\n        if (before)\n            return { type: \"attrName\", from: pos, context: inTag };\n        return null;\n    }\n    else if (at.name == \"StartCloseTag\") {\n        return { type: \"closeTag\", from: pos, context: at.parent };\n    }\n    while (at.parent && at.to == pos && !((_a = at.lastChild) === null || _a === void 0 ? void 0 : _a.type.isError))\n        at = at.parent;\n    if (at.name == \"Element\" || at.name == \"Text\" || at.name == \"Document\")\n        return { type: \"tag\", from: pos, context: at.name == \"Element\" ? at : findParentElement(at) };\n    return null;\n}\nclass Element {\n    constructor(spec, attrs, attrValues) {\n        this.attrs = attrs;\n        this.attrValues = attrValues;\n        this.children = [];\n        this.name = spec.name;\n        this.completion = Object.assign(Object.assign({ type: \"type\" }, spec.completion || {}), { label: this.name });\n        this.openCompletion = Object.assign(Object.assign({}, this.completion), { label: \"<\" + this.name });\n        this.closeCompletion = Object.assign(Object.assign({}, this.completion), { label: \"</\" + this.name + \">\", boost: 2 });\n        this.closeNameCompletion = Object.assign(Object.assign({}, this.completion), { label: this.name + \">\" });\n        this.text = spec.textContent ? spec.textContent.map(s => ({ label: s, type: \"text\" })) : [];\n    }\n}\nconst Identifier = /^[:\\-\\.\\w\\u00b7-\\uffff]*$/;\nfunction attrCompletion(spec) {\n    return Object.assign(Object.assign({ type: \"property\" }, spec.completion || {}), { label: spec.name });\n}\nfunction valueCompletion(spec) {\n    return typeof spec == \"string\" ? { label: `\"${spec}\"`, type: \"constant\" }\n        : /^\"/.test(spec.label) ? spec\n            : Object.assign(Object.assign({}, spec), { label: `\"${spec.label}\"` });\n}\nfunction completeFromSchema(eltSpecs, attrSpecs) {\n    let allAttrs = [], globalAttrs = [];\n    let attrValues = Object.create(null);\n    for (let s of attrSpecs) {\n        let completion = attrCompletion(s);\n        allAttrs.push(completion);\n        if (s.global)\n            globalAttrs.push(completion);\n        if (s.values)\n            attrValues[s.name] = s.values.map(valueCompletion);\n    }\n    let allElements = [], topElements = [];\n    let byName = Object.create(null);\n    for (let s of eltSpecs) {\n        let attrs = globalAttrs, attrVals = attrValues;\n        if (s.attributes)\n            attrs = attrs.concat(s.attributes.map(s => {\n                if (typeof s == \"string\")\n                    return allAttrs.find(a => a.label == s) || { label: s, type: \"property\" };\n                if (s.values) {\n                    if (attrVals == attrValues)\n                        attrVals = Object.create(attrVals);\n                    attrVals[s.name] = s.values.map(valueCompletion);\n                }\n                return attrCompletion(s);\n            }));\n        let elt = new Element(s, attrs, attrVals);\n        byName[elt.name] = elt;\n        allElements.push(elt);\n        if (s.top)\n            topElements.push(elt);\n    }\n    if (!topElements.length)\n        topElements = allElements;\n    for (let i = 0; i < allElements.length; i++) {\n        let s = eltSpecs[i], elt = allElements[i];\n        if (s.children) {\n            for (let ch of s.children)\n                if (byName[ch])\n                    elt.children.push(byName[ch]);\n        }\n        else {\n            elt.children = allElements;\n        }\n    }\n    return cx => {\n        var _a;\n        let { doc } = cx.state, loc = findLocation(cx.state, cx.pos);\n        if (!loc || (loc.type == \"tag\" && !cx.explicit))\n            return null;\n        let { type, from, context } = loc;\n        if (type == \"openTag\") {\n            let children = topElements;\n            let parentName = elementName(doc, context);\n            if (parentName) {\n                let parent = byName[parentName];\n                children = (parent === null || parent === void 0 ? void 0 : parent.children) || allElements;\n            }\n            return {\n                from,\n                options: children.map(ch => ch.completion),\n                span: Identifier\n            };\n        }\n        else if (type == \"closeTag\") {\n            let parentName = elementName(doc, context);\n            return parentName ? {\n                from,\n                to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == \">\" ? 1 : 0),\n                options: [((_a = byName[parentName]) === null || _a === void 0 ? void 0 : _a.closeNameCompletion) || { label: parentName + \">\", type: \"type\" }],\n                span: Identifier\n            } : null;\n        }\n        else if (type == \"attrName\") {\n            let parent = byName[tagName(doc, context)];\n            return {\n                from,\n                options: (parent === null || parent === void 0 ? void 0 : parent.attrs) || globalAttrs,\n                span: Identifier\n            };\n        }\n        else if (type == \"attrValue\") {\n            let attr = attrName(doc, context, from);\n            if (!attr)\n                return null;\n            let parent = byName[tagName(doc, context)];\n            let values = ((parent === null || parent === void 0 ? void 0 : parent.attrValues) || attrValues)[attr];\n            if (!values || !values.length)\n                return null;\n            return {\n                from,\n                to: cx.pos + (doc.sliceString(cx.pos, cx.pos + 1) == '\"' ? 1 : 0),\n                options: values,\n                span: /^\"[^\"]*\"?$/\n            };\n        }\n        else if (type == \"tag\") {\n            let parentName = elementName(doc, context), parent = byName[parentName];\n            let closing = [], last = context && context.lastChild;\n            if (parentName && (!last || last.name != \"CloseTag\" || tagName(doc, last) != parentName))\n                closing.push(parent ? parent.closeCompletion : { label: \"</\" + parentName + \">\", type: \"type\", boost: 2 });\n            let options = closing.concat(((parent === null || parent === void 0 ? void 0 : parent.children) || (context ? allElements : topElements)).map(e => e.openCompletion));\n            if (context && (parent === null || parent === void 0 ? void 0 : parent.text.length)) {\n                let openTag = context.firstChild;\n                if (openTag.to > cx.pos - 20 && !/\\S/.test(cx.state.sliceDoc(openTag.to, cx.pos)))\n                    options = options.concat(parent.text);\n            }\n            return {\n                from,\n                options,\n                span: /^<\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/\n            };\n        }\n        else {\n            return null;\n        }\n    };\n}\n\n/**\nA language provider based on the [Lezer XML\nparser](https://github.com/lezer-parser/xml), extended with\nhighlighting and indentation information.\n*/\nconst xmlLanguage = /*@__PURE__*/LRLanguage.define({\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                Element(context) {\n                    let closed = /^\\s*<\\//.test(context.textAfter);\n                    return context.lineIndent(context.node.from) + (closed ? 0 : context.unit);\n                },\n                \"OpenTag CloseTag SelfClosingTag\"(context) {\n                    return context.column(context.node.from) + context.unit;\n                }\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                Element(subtree) {\n                    let first = subtree.firstChild, last = subtree.lastChild;\n                    if (!first || first.name != \"OpenTag\")\n                        return null;\n                    return { from: first.to, to: last.name == \"CloseTag\" ? last.from : subtree.to };\n                }\n            }),\n            /*@__PURE__*/styleTags({\n                Text: tags.content,\n                \"StartTag StartCloseTag EndTag SelfCloseEndTag\": tags.angleBracket,\n                TagName: tags.tagName,\n                \"MismatchedCloseTag/Tagname\": [tags.tagName, tags.invalid],\n                AttributeName: tags.attributeName,\n                AttributeValue: tags.attributeValue,\n                Is: tags.definitionOperator,\n                \"EntityReference CharacterReference\": tags.character,\n                Comment: tags.blockComment,\n                ProcessingInst: tags.processingInstruction,\n                DoctypeDecl: tags.documentMeta,\n                Cdata: /*@__PURE__*/tags.special(tags.string)\n            })\n        ]\n    }),\n    languageData: {\n        commentTokens: { block: { open: \"<!--\", close: \"-->\" } },\n        indentOnInput: /^\\s*<\\/$/\n    }\n});\n/**\nXML language support. Includes schema-based autocompletion when\nconfigured.\n*/\nfunction xml(conf = {}) {\n    return new LanguageSupport(xmlLanguage, xmlLanguage.data.of({\n        autocomplete: completeFromSchema(conf.elements || [], conf.attributes || [])\n    }));\n}\n\nexport { completeFromSchema, xml, xmlLanguage };\n"]},"metadata":{},"sourceType":"module"}