{"ast":null,"code":"import { StateEffect, StateField, Facet, combineConfig } from '@codemirror/state';\nimport { Decoration, EditorView, WidgetType, ViewPlugin } from '@codemirror/view';\nimport { foldable, language } from '@codemirror/language';\nimport { gutter, GutterMarker } from '@codemirror/gutter';\nimport { RangeSet, RangeSetBuilder } from '@codemirror/rangeset';\n\nfunction mapRange(range, mapping) {\n  let from = mapping.mapPos(range.from, 1),\n      to = mapping.mapPos(range.to, -1);\n  return from >= to ? undefined : {\n    from,\n    to\n  };\n}\n/**\nState effect that can be attached to a transaction to fold the\ngiven range. (You probably only need this in exceptional\ncircumstances—usually you'll just want to let\n[`foldCode`](https://codemirror.net/6/docs/ref/#fold.foldCode) and the [fold\ngutter](https://codemirror.net/6/docs/ref/#fold.foldGutter) create the transactions.)\n*/\n\n\nconst foldEffect = /*@__PURE__*/StateEffect.define({\n  map: mapRange\n});\n/**\nState effect that unfolds the given range (if it was folded).\n*/\n\nconst unfoldEffect = /*@__PURE__*/StateEffect.define({\n  map: mapRange\n});\n\nfunction selectedLines(view) {\n  let lines = [];\n\n  for (let {\n    head\n  } of view.state.selection.ranges) {\n    if (lines.some(l => l.from <= head && l.to >= head)) continue;\n    lines.push(view.lineBlockAt(head));\n  }\n\n  return lines;\n}\n\nconst foldState = /*@__PURE__*/StateField.define({\n  create() {\n    return Decoration.none;\n  },\n\n  update(folded, tr) {\n    folded = folded.map(tr.changes);\n\n    for (let e of tr.effects) {\n      if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) folded = folded.update({\n        add: [foldWidget.range(e.value.from, e.value.to)]\n      });else if (e.is(unfoldEffect)) folded = folded.update({\n        filter: (from, to) => e.value.from != from || e.value.to != to,\n        filterFrom: e.value.from,\n        filterTo: e.value.to\n      });\n    } // Clear folded ranges that cover the selection head\n\n\n    if (tr.selection) {\n      let onSelection = false,\n          {\n        head\n      } = tr.selection.main;\n      folded.between(head, head, (a, b) => {\n        if (a < head && b > head) onSelection = true;\n      });\n      if (onSelection) folded = folded.update({\n        filterFrom: head,\n        filterTo: head,\n        filter: (a, b) => b <= head || a >= head\n      });\n    }\n\n    return folded;\n  },\n\n  provide: f => EditorView.decorations.from(f)\n});\n/**\nGet a [range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) containing the folded ranges\nin the given state.\n*/\n\nfunction foldedRanges(state) {\n  return state.field(foldState, false) || RangeSet.empty;\n}\n\nfunction foldInside(state, from, to) {\n  var _a;\n\n  let found = null;\n  (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {\n    if (!found || found.from > from) found = {\n      from,\n      to\n    };\n  });\n  return found;\n}\n\nfunction foldExists(folded, from, to) {\n  let found = false;\n  folded.between(from, from, (a, b) => {\n    if (a == from && b == to) found = true;\n  });\n  return found;\n}\n\nfunction maybeEnable(state, other) {\n  return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));\n}\n/**\nFold the lines that are selected, if possible.\n*/\n\n\nconst foldCode = view => {\n  for (let line of selectedLines(view)) {\n    let range = foldable(view.state, line.from, line.to);\n\n    if (range) {\n      view.dispatch({\n        effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)])\n      });\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\nUnfold folded ranges on selected lines.\n*/\n\n\nconst unfoldCode = view => {\n  if (!view.state.field(foldState, false)) return false;\n  let effects = [];\n\n  for (let line of selectedLines(view)) {\n    let folded = foldInside(view.state, line.from, line.to);\n    if (folded) effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n  }\n\n  if (effects.length) view.dispatch({\n    effects\n  });\n  return effects.length > 0;\n};\n\nfunction announceFold(view, range) {\n  let fold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  let lineFrom = view.state.doc.lineAt(range.from).number,\n      lineTo = view.state.doc.lineAt(range.to).number;\n  return EditorView.announce.of(`${view.state.phrase(fold ? \"Folded lines\" : \"Unfolded lines\")} ${lineFrom} ${view.state.phrase(\"to\")} ${lineTo}.`);\n}\n/**\nFold all top-level foldable ranges.\n*/\n\n\nconst foldAll = view => {\n  let {\n    state\n  } = view,\n      effects = [];\n\n  for (let pos = 0; pos < state.doc.length;) {\n    let line = view.lineBlockAt(pos),\n        range = foldable(state, line.from, line.to);\n    if (range) effects.push(foldEffect.of(range));\n    pos = (range ? view.lineBlockAt(range.to) : line).to + 1;\n  }\n\n  if (effects.length) view.dispatch({\n    effects: maybeEnable(view.state, effects)\n  });\n  return !!effects.length;\n};\n/**\nUnfold all folded code.\n*/\n\n\nconst unfoldAll = view => {\n  let field = view.state.field(foldState, false);\n  if (!field || !field.size) return false;\n  let effects = [];\n  field.between(0, view.state.doc.length, (from, to) => {\n    effects.push(unfoldEffect.of({\n      from,\n      to\n    }));\n  });\n  view.dispatch({\n    effects\n  });\n  return true;\n};\n/**\nDefault fold-related key bindings.\n\n - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#fold.foldCode).\n - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#fold.unfoldCode).\n - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#fold.foldAll).\n - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#fold.unfoldAll).\n*/\n\n\nconst foldKeymap = [{\n  key: \"Ctrl-Shift-[\",\n  mac: \"Cmd-Alt-[\",\n  run: foldCode\n}, {\n  key: \"Ctrl-Shift-]\",\n  mac: \"Cmd-Alt-]\",\n  run: unfoldCode\n}, {\n  key: \"Ctrl-Alt-[\",\n  run: foldAll\n}, {\n  key: \"Ctrl-Alt-]\",\n  run: unfoldAll\n}];\nconst defaultConfig = {\n  placeholderDOM: null,\n  placeholderText: \"…\"\n};\nconst foldConfig = /*@__PURE__*/Facet.define({\n  combine(values) {\n    return combineConfig(values, defaultConfig);\n  }\n\n});\n/**\nCreate an extension that configures code folding.\n*/\n\nfunction codeFolding(config) {\n  let result = [foldState, baseTheme];\n  if (config) result.push(foldConfig.of(config));\n  return result;\n}\n\nconst foldWidget = /*@__PURE__*/Decoration.replace({\n  widget: /*@__PURE__*/new class extends WidgetType {\n    ignoreEvents() {\n      return false;\n    }\n\n    toDOM(view) {\n      let {\n        state\n      } = view,\n          conf = state.facet(foldConfig);\n\n      let onclick = event => {\n        let line = view.lineBlockAt(view.posAtDOM(event.target));\n        let folded = foldInside(view.state, line.from, line.to);\n        if (folded) view.dispatch({\n          effects: unfoldEffect.of(folded)\n        });\n        event.preventDefault();\n      };\n\n      if (conf.placeholderDOM) return conf.placeholderDOM(view, onclick);\n      let element = document.createElement(\"span\");\n      element.textContent = conf.placeholderText;\n      element.setAttribute(\"aria-label\", state.phrase(\"folded code\"));\n      element.title = state.phrase(\"unfold\");\n      element.className = \"cm-foldPlaceholder\";\n      element.onclick = onclick;\n      return element;\n    }\n\n  }()\n});\nconst foldGutterDefaults = {\n  openText: \"⌄\",\n  closedText: \"›\",\n  markerDOM: null\n};\n\nclass FoldMarker extends GutterMarker {\n  constructor(config, open) {\n    super();\n    this.config = config;\n    this.open = open;\n  }\n\n  eq(other) {\n    return this.config == other.config && this.open == other.open;\n  }\n\n  toDOM(view) {\n    if (this.config.markerDOM) return this.config.markerDOM(this.open);\n    let span = document.createElement(\"span\");\n    span.textContent = this.open ? this.config.openText : this.config.closedText;\n    span.title = view.state.phrase(this.open ? \"Fold line\" : \"Unfold line\");\n    return span;\n  }\n\n}\n/**\nCreate an extension that registers a fold gutter, which shows a\nfold status indicator before foldable lines (which can be clicked\nto fold or unfold the line).\n*/\n\n\nfunction foldGutter() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);\n  let canFold = new FoldMarker(fullConfig, true),\n      canUnfold = new FoldMarker(fullConfig, false);\n  let markers = ViewPlugin.fromClass(class {\n    constructor(view) {\n      this.from = view.viewport.from;\n      this.markers = this.buildMarkers(view);\n    }\n\n    update(update) {\n      if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false)) this.markers = this.buildMarkers(update.view);\n    }\n\n    buildMarkers(view) {\n      let builder = new RangeSetBuilder();\n\n      for (let line of view.viewportLineBlocks) {\n        let mark = foldInside(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;\n        if (mark) builder.add(line.from, line.from, mark);\n      }\n\n      return builder.finish();\n    }\n\n  });\n  return [markers, gutter({\n    class: \"cm-foldGutter\",\n\n    markers(view) {\n      var _a;\n\n      return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || RangeSet.empty;\n    },\n\n    initialSpacer() {\n      return new FoldMarker(fullConfig, false);\n    },\n\n    domEventHandlers: {\n      click: (view, line) => {\n        let folded = foldInside(view.state, line.from, line.to);\n\n        if (folded) {\n          view.dispatch({\n            effects: unfoldEffect.of(folded)\n          });\n          return true;\n        }\n\n        let range = foldable(view.state, line.from, line.to);\n\n        if (range) {\n          view.dispatch({\n            effects: foldEffect.of(range)\n          });\n          return true;\n        }\n\n        return false;\n      }\n    }\n  }), codeFolding()];\n}\n\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-foldPlaceholder\": {\n    backgroundColor: \"#eee\",\n    border: \"1px solid #ddd\",\n    color: \"#888\",\n    borderRadius: \".2em\",\n    margin: \"0 1px\",\n    padding: \"0 1px\",\n    cursor: \"pointer\"\n  },\n  \".cm-foldGutter span\": {\n    padding: \"0 1px\",\n    cursor: \"pointer\"\n  }\n});\nexport { codeFolding, foldAll, foldCode, foldEffect, foldGutter, foldKeymap, foldedRanges, unfoldAll, unfoldCode, unfoldEffect };","map":{"version":3,"sources":["C:/Users/pc/Desktop/live-code-editor/client/node_modules/@codemirror/fold/dist/index.js"],"names":["StateEffect","StateField","Facet","combineConfig","Decoration","EditorView","WidgetType","ViewPlugin","foldable","language","gutter","GutterMarker","RangeSet","RangeSetBuilder","mapRange","range","mapping","from","mapPos","to","undefined","foldEffect","define","map","unfoldEffect","selectedLines","view","lines","head","state","selection","ranges","some","l","push","lineBlockAt","foldState","create","none","update","folded","tr","changes","e","effects","is","foldExists","value","add","foldWidget","filter","filterFrom","filterTo","onSelection","main","between","a","b","provide","f","decorations","foldedRanges","field","empty","foldInside","_a","found","maybeEnable","other","concat","appendConfig","of","codeFolding","foldCode","line","dispatch","announceFold","unfoldCode","length","fold","lineFrom","doc","lineAt","number","lineTo","announce","phrase","foldAll","pos","unfoldAll","size","foldKeymap","key","mac","run","defaultConfig","placeholderDOM","placeholderText","foldConfig","combine","values","config","result","baseTheme","replace","widget","ignoreEvents","toDOM","conf","facet","onclick","event","posAtDOM","target","preventDefault","element","document","createElement","textContent","setAttribute","title","className","foldGutterDefaults","openText","closedText","markerDOM","FoldMarker","constructor","open","eq","span","foldGutter","fullConfig","Object","assign","canFold","canUnfold","markers","fromClass","viewport","buildMarkers","docChanged","viewportChanged","startState","builder","viewportLineBlocks","mark","finish","class","plugin","initialSpacer","domEventHandlers","click","backgroundColor","border","color","borderRadius","margin","padding","cursor"],"mappings":"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","sourcesContent":["import { StateEffect, StateField, Facet, combineConfig } from '@codemirror/state';\nimport { Decoration, EditorView, WidgetType, ViewPlugin } from '@codemirror/view';\nimport { foldable, language } from '@codemirror/language';\nimport { gutter, GutterMarker } from '@codemirror/gutter';\nimport { RangeSet, RangeSetBuilder } from '@codemirror/rangeset';\n\nfunction mapRange(range, mapping) {\n    let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);\n    return from >= to ? undefined : { from, to };\n}\n/**\nState effect that can be attached to a transaction to fold the\ngiven range. (You probably only need this in exceptional\ncircumstances—usually you'll just want to let\n[`foldCode`](https://codemirror.net/6/docs/ref/#fold.foldCode) and the [fold\ngutter](https://codemirror.net/6/docs/ref/#fold.foldGutter) create the transactions.)\n*/\nconst foldEffect = /*@__PURE__*/StateEffect.define({ map: mapRange });\n/**\nState effect that unfolds the given range (if it was folded).\n*/\nconst unfoldEffect = /*@__PURE__*/StateEffect.define({ map: mapRange });\nfunction selectedLines(view) {\n    let lines = [];\n    for (let { head } of view.state.selection.ranges) {\n        if (lines.some(l => l.from <= head && l.to >= head))\n            continue;\n        lines.push(view.lineBlockAt(head));\n    }\n    return lines;\n}\nconst foldState = /*@__PURE__*/StateField.define({\n    create() {\n        return Decoration.none;\n    },\n    update(folded, tr) {\n        folded = folded.map(tr.changes);\n        for (let e of tr.effects) {\n            if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to))\n                folded = folded.update({ add: [foldWidget.range(e.value.from, e.value.to)] });\n            else if (e.is(unfoldEffect))\n                folded = folded.update({ filter: (from, to) => e.value.from != from || e.value.to != to,\n                    filterFrom: e.value.from, filterTo: e.value.to });\n        }\n        // Clear folded ranges that cover the selection head\n        if (tr.selection) {\n            let onSelection = false, { head } = tr.selection.main;\n            folded.between(head, head, (a, b) => { if (a < head && b > head)\n                onSelection = true; });\n            if (onSelection)\n                folded = folded.update({\n                    filterFrom: head,\n                    filterTo: head,\n                    filter: (a, b) => b <= head || a >= head\n                });\n        }\n        return folded;\n    },\n    provide: f => EditorView.decorations.from(f)\n});\n/**\nGet a [range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) containing the folded ranges\nin the given state.\n*/\nfunction foldedRanges(state) {\n    return state.field(foldState, false) || RangeSet.empty;\n}\nfunction foldInside(state, from, to) {\n    var _a;\n    let found = null;\n    (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {\n        if (!found || found.from > from)\n            found = { from, to };\n    });\n    return found;\n}\nfunction foldExists(folded, from, to) {\n    let found = false;\n    folded.between(from, from, (a, b) => { if (a == from && b == to)\n        found = true; });\n    return found;\n}\nfunction maybeEnable(state, other) {\n    return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));\n}\n/**\nFold the lines that are selected, if possible.\n*/\nconst foldCode = view => {\n    for (let line of selectedLines(view)) {\n        let range = foldable(view.state, line.from, line.to);\n        if (range) {\n            view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });\n            return true;\n        }\n    }\n    return false;\n};\n/**\nUnfold folded ranges on selected lines.\n*/\nconst unfoldCode = view => {\n    if (!view.state.field(foldState, false))\n        return false;\n    let effects = [];\n    for (let line of selectedLines(view)) {\n        let folded = foldInside(view.state, line.from, line.to);\n        if (folded)\n            effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n    }\n    if (effects.length)\n        view.dispatch({ effects });\n    return effects.length > 0;\n};\nfunction announceFold(view, range, fold = true) {\n    let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;\n    return EditorView.announce.of(`${view.state.phrase(fold ? \"Folded lines\" : \"Unfolded lines\")} ${lineFrom} ${view.state.phrase(\"to\")} ${lineTo}.`);\n}\n/**\nFold all top-level foldable ranges.\n*/\nconst foldAll = view => {\n    let { state } = view, effects = [];\n    for (let pos = 0; pos < state.doc.length;) {\n        let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);\n        if (range)\n            effects.push(foldEffect.of(range));\n        pos = (range ? view.lineBlockAt(range.to) : line).to + 1;\n    }\n    if (effects.length)\n        view.dispatch({ effects: maybeEnable(view.state, effects) });\n    return !!effects.length;\n};\n/**\nUnfold all folded code.\n*/\nconst unfoldAll = view => {\n    let field = view.state.field(foldState, false);\n    if (!field || !field.size)\n        return false;\n    let effects = [];\n    field.between(0, view.state.doc.length, (from, to) => { effects.push(unfoldEffect.of({ from, to })); });\n    view.dispatch({ effects });\n    return true;\n};\n/**\nDefault fold-related key bindings.\n\n - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#fold.foldCode).\n - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#fold.unfoldCode).\n - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#fold.foldAll).\n - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#fold.unfoldAll).\n*/\nconst foldKeymap = [\n    { key: \"Ctrl-Shift-[\", mac: \"Cmd-Alt-[\", run: foldCode },\n    { key: \"Ctrl-Shift-]\", mac: \"Cmd-Alt-]\", run: unfoldCode },\n    { key: \"Ctrl-Alt-[\", run: foldAll },\n    { key: \"Ctrl-Alt-]\", run: unfoldAll }\n];\nconst defaultConfig = {\n    placeholderDOM: null,\n    placeholderText: \"…\"\n};\nconst foldConfig = /*@__PURE__*/Facet.define({\n    combine(values) { return combineConfig(values, defaultConfig); }\n});\n/**\nCreate an extension that configures code folding.\n*/\nfunction codeFolding(config) {\n    let result = [foldState, baseTheme];\n    if (config)\n        result.push(foldConfig.of(config));\n    return result;\n}\nconst foldWidget = /*@__PURE__*/Decoration.replace({ widget: /*@__PURE__*/new class extends WidgetType {\n        ignoreEvents() { return false; }\n        toDOM(view) {\n            let { state } = view, conf = state.facet(foldConfig);\n            let onclick = (event) => {\n                let line = view.lineBlockAt(view.posAtDOM(event.target));\n                let folded = foldInside(view.state, line.from, line.to);\n                if (folded)\n                    view.dispatch({ effects: unfoldEffect.of(folded) });\n                event.preventDefault();\n            };\n            if (conf.placeholderDOM)\n                return conf.placeholderDOM(view, onclick);\n            let element = document.createElement(\"span\");\n            element.textContent = conf.placeholderText;\n            element.setAttribute(\"aria-label\", state.phrase(\"folded code\"));\n            element.title = state.phrase(\"unfold\");\n            element.className = \"cm-foldPlaceholder\";\n            element.onclick = onclick;\n            return element;\n        }\n    } });\nconst foldGutterDefaults = {\n    openText: \"⌄\",\n    closedText: \"›\",\n    markerDOM: null,\n};\nclass FoldMarker extends GutterMarker {\n    constructor(config, open) {\n        super();\n        this.config = config;\n        this.open = open;\n    }\n    eq(other) { return this.config == other.config && this.open == other.open; }\n    toDOM(view) {\n        if (this.config.markerDOM)\n            return this.config.markerDOM(this.open);\n        let span = document.createElement(\"span\");\n        span.textContent = this.open ? this.config.openText : this.config.closedText;\n        span.title = view.state.phrase(this.open ? \"Fold line\" : \"Unfold line\");\n        return span;\n    }\n}\n/**\nCreate an extension that registers a fold gutter, which shows a\nfold status indicator before foldable lines (which can be clicked\nto fold or unfold the line).\n*/\nfunction foldGutter(config = {}) {\n    let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);\n    let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);\n    let markers = ViewPlugin.fromClass(class {\n        constructor(view) {\n            this.from = view.viewport.from;\n            this.markers = this.buildMarkers(view);\n        }\n        update(update) {\n            if (update.docChanged || update.viewportChanged ||\n                update.startState.facet(language) != update.state.facet(language) ||\n                update.startState.field(foldState, false) != update.state.field(foldState, false))\n                this.markers = this.buildMarkers(update.view);\n        }\n        buildMarkers(view) {\n            let builder = new RangeSetBuilder();\n            for (let line of view.viewportLineBlocks) {\n                let mark = foldInside(view.state, line.from, line.to) ? canUnfold\n                    : foldable(view.state, line.from, line.to) ? canFold : null;\n                if (mark)\n                    builder.add(line.from, line.from, mark);\n            }\n            return builder.finish();\n        }\n    });\n    return [\n        markers,\n        gutter({\n            class: \"cm-foldGutter\",\n            markers(view) { var _a; return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || RangeSet.empty; },\n            initialSpacer() {\n                return new FoldMarker(fullConfig, false);\n            },\n            domEventHandlers: {\n                click: (view, line) => {\n                    let folded = foldInside(view.state, line.from, line.to);\n                    if (folded) {\n                        view.dispatch({ effects: unfoldEffect.of(folded) });\n                        return true;\n                    }\n                    let range = foldable(view.state, line.from, line.to);\n                    if (range) {\n                        view.dispatch({ effects: foldEffect.of(range) });\n                        return true;\n                    }\n                    return false;\n                }\n            }\n        }),\n        codeFolding()\n    ];\n}\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-foldPlaceholder\": {\n        backgroundColor: \"#eee\",\n        border: \"1px solid #ddd\",\n        color: \"#888\",\n        borderRadius: \".2em\",\n        margin: \"0 1px\",\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    },\n    \".cm-foldGutter span\": {\n        padding: \"0 1px\",\n        cursor: \"pointer\"\n    }\n});\n\nexport { codeFolding, foldAll, foldCode, foldEffect, foldGutter, foldKeymap, foldedRanges, unfoldAll, unfoldCode, unfoldEffect };\n"]},"metadata":{},"sourceType":"module"}