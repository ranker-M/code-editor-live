{"ast":null,"code":"import { parser } from '@lezer/lezer';\nimport { LRLanguage, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { styleTags, tags } from '@codemirror/highlight';\n/**\nA language provider based on the [Lezer Lezer\nparser](https://github.com/lezer-parser/lezer-grammar), extended\nwith highlighting and indentation information.\n*/\n\nconst lezerLanguage = /*@__PURE__*/LRLanguage.define({\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/foldNodeProp.add({\n      \"Body TokensBody SkipBody PrecedenceBody\": foldInside\n    }), /*@__PURE__*/styleTags({\n      LineComment: tags.lineComment,\n      BlockComment: tags.blockComment,\n      AnyChar: tags.character,\n      Literal: tags.string,\n      \"tokens from grammar as empty prop extend specialize\": tags.keyword,\n      \"@top @left @right @cut @external\": tags.modifier,\n      \"@precedence @tokens @context @dialects @skip @detectDelim @conflict\": tags.definitionKeyword,\n      \"@extend @specialize\": tags.operatorKeyword,\n      \"CharSet InvertedCharSet\": tags.regexp,\n      RuleName: tags.variableName,\n      \"RuleDeclaration/RuleName InlineRule/RuleName TokensBody/RuleName\": /*@__PURE__*/tags.definition(tags.variableName),\n      PrecedenceName: tags.labelName,\n      Name: tags.name,\n      \"( )\": tags.paren,\n      \"[ ]\": tags.squareBracket,\n      \"{ }\": tags.brace,\n      '\"!\" ~ \"*\" + ? |': tags.operator\n    })]\n  }),\n  languageData: {\n    commentTokens: {\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      },\n      line: \"//\"\n    },\n    indentOnInput: /^\\s*\\}$/\n  }\n});\n/**\nLanguage support for Lezer grammars.\n*/\n\nfunction lezer() {\n  return new LanguageSupport(lezerLanguage);\n}\n\nexport { lezer, lezerLanguage };","map":{"version":3,"sources":["C:/Users/pc/Desktop/live-code-editor/client/node_modules/@codemirror/lang-lezer/dist/index.js"],"names":["parser","LRLanguage","foldNodeProp","foldInside","LanguageSupport","styleTags","tags","lezerLanguage","define","configure","props","add","LineComment","lineComment","BlockComment","blockComment","AnyChar","character","Literal","string","keyword","modifier","definitionKeyword","operatorKeyword","regexp","RuleName","variableName","definition","PrecedenceName","labelName","Name","name","paren","squareBracket","brace","operator","languageData","commentTokens","block","open","close","line","indentOnInput","lezer"],"mappings":"AAAA,SAASA,MAAT,QAAuB,cAAvB;AACA,SAASC,UAAT,EAAqBC,YAArB,EAAmCC,UAAnC,EAA+CC,eAA/C,QAAsE,sBAAtE;AACA,SAASC,SAAT,EAAoBC,IAApB,QAAgC,uBAAhC;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMC,aAAa,GAAG,aAAaN,UAAU,CAACO,MAAX,CAAkB;AACjDR,EAAAA,MAAM,EAAE,aAAaA,MAAM,CAACS,SAAP,CAAiB;AAClCC,IAAAA,KAAK,EAAE,CACH,aAAaR,YAAY,CAACS,GAAb,CAAiB;AAC1B,iDAA2CR;AADjB,KAAjB,CADV,EAIH,aAAaE,SAAS,CAAC;AACnBO,MAAAA,WAAW,EAAEN,IAAI,CAACO,WADC;AAEnBC,MAAAA,YAAY,EAAER,IAAI,CAACS,YAFA;AAGnBC,MAAAA,OAAO,EAAEV,IAAI,CAACW,SAHK;AAInBC,MAAAA,OAAO,EAAEZ,IAAI,CAACa,MAJK;AAKnB,6DAAuDb,IAAI,CAACc,OALzC;AAMnB,0CAAoCd,IAAI,CAACe,QANtB;AAOnB,6EAAuEf,IAAI,CAACgB,iBAPzD;AAQnB,6BAAuBhB,IAAI,CAACiB,eART;AASnB,iCAA2BjB,IAAI,CAACkB,MATb;AAUnBC,MAAAA,QAAQ,EAAEnB,IAAI,CAACoB,YAVI;AAWnB,0EAAoE,aAAapB,IAAI,CAACqB,UAAL,CAAgBrB,IAAI,CAACoB,YAArB,CAX9D;AAYnBE,MAAAA,cAAc,EAAEtB,IAAI,CAACuB,SAZF;AAanBC,MAAAA,IAAI,EAAExB,IAAI,CAACyB,IAbQ;AAcnB,aAAOzB,IAAI,CAAC0B,KAdO;AAenB,aAAO1B,IAAI,CAAC2B,aAfO;AAgBnB,aAAO3B,IAAI,CAAC4B,KAhBO;AAiBnB,yBAAmB5B,IAAI,CAAC6B;AAjBL,KAAD,CAJnB;AAD2B,GAAjB,CAD4B;AA2BjDC,EAAAA,YAAY,EAAE;AACVC,IAAAA,aAAa,EAAE;AAAEC,MAAAA,KAAK,EAAE;AAAEC,QAAAA,IAAI,EAAE,IAAR;AAAcC,QAAAA,KAAK,EAAE;AAArB,OAAT;AAAsCC,MAAAA,IAAI,EAAE;AAA5C,KADL;AAEVC,IAAAA,aAAa,EAAE;AAFL;AA3BmC,CAAlB,CAAnC;AAgCA;AACA;AACA;;AACA,SAASC,KAAT,GAAiB;AACb,SAAO,IAAIvC,eAAJ,CAAoBG,aAApB,CAAP;AACH;;AAED,SAASoC,KAAT,EAAgBpC,aAAhB","sourcesContent":["import { parser } from '@lezer/lezer';\nimport { LRLanguage, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { styleTags, tags } from '@codemirror/highlight';\n\n/**\nA language provider based on the [Lezer Lezer\nparser](https://github.com/lezer-parser/lezer-grammar), extended\nwith highlighting and indentation information.\n*/\nconst lezerLanguage = /*@__PURE__*/LRLanguage.define({\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/foldNodeProp.add({\n                \"Body TokensBody SkipBody PrecedenceBody\": foldInside\n            }),\n            /*@__PURE__*/styleTags({\n                LineComment: tags.lineComment,\n                BlockComment: tags.blockComment,\n                AnyChar: tags.character,\n                Literal: tags.string,\n                \"tokens from grammar as empty prop extend specialize\": tags.keyword,\n                \"@top @left @right @cut @external\": tags.modifier,\n                \"@precedence @tokens @context @dialects @skip @detectDelim @conflict\": tags.definitionKeyword,\n                \"@extend @specialize\": tags.operatorKeyword,\n                \"CharSet InvertedCharSet\": tags.regexp,\n                RuleName: tags.variableName,\n                \"RuleDeclaration/RuleName InlineRule/RuleName TokensBody/RuleName\": /*@__PURE__*/tags.definition(tags.variableName),\n                PrecedenceName: tags.labelName,\n                Name: tags.name,\n                \"( )\": tags.paren,\n                \"[ ]\": tags.squareBracket,\n                \"{ }\": tags.brace,\n                '\"!\" ~ \"*\" + ? |': tags.operator\n            })\n        ]\n    }),\n    languageData: {\n        commentTokens: { block: { open: \"/*\", close: \"*/\" }, line: \"//\" },\n        indentOnInput: /^\\s*\\}$/\n    }\n});\n/**\nLanguage support for Lezer grammars.\n*/\nfunction lezer() {\n    return new LanguageSupport(lezerLanguage);\n}\n\nexport { lezer, lezerLanguage };\n"]},"metadata":{},"sourceType":"module"}