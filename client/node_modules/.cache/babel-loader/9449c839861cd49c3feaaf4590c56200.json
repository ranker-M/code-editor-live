{"ast":null,"code":"import { EditorSelection } from '@codemirror/state';\n/**\nComment or uncomment the current selection. Will use line comments\nif available, otherwise falling back to block comments.\n*/\n\nconst toggleComment = target => {\n  let config = getConfig(target.state);\n  return config.line ? toggleLineComment(target) : config.block ? toggleBlockComment(target) : false;\n};\n\nfunction command(f, option) {\n  return _ref => {\n    let {\n      state,\n      dispatch\n    } = _ref;\n    let tr = f(option, state.selection.ranges, state);\n    if (!tr) return false;\n    dispatch(state.update(tr));\n    return true;\n  };\n}\n/**\nComment or uncomment the current selection using line comments.\nThe line comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#comment.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\n\n\nconst toggleLineComment = /*@__PURE__*/command(changeLineComment, 0\n/* Toggle */\n);\n/**\nComment the current selection using line comments.\n*/\n\nconst lineComment = /*@__PURE__*/command(changeLineComment, 1\n/* Comment */\n);\n/**\nUncomment the current selection using line comments.\n*/\n\nconst lineUncomment = /*@__PURE__*/command(changeLineComment, 2\n/* Uncomment */\n);\n/**\nComment or uncomment the current selection using block comments.\nThe block comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#comment.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\n\nconst toggleBlockComment = /*@__PURE__*/command(changeBlockComment, 0\n/* Toggle */\n);\n/**\nComment the current selection using block comments.\n*/\n\nconst blockComment = /*@__PURE__*/command(changeBlockComment, 1\n/* Comment */\n);\n/**\nUncomment the current selection using block comments.\n*/\n\nconst blockUncomment = /*@__PURE__*/command(changeBlockComment, 2\n/* Uncomment */\n);\n/**\nDefault key bindings for this package.\n\n - Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#comment.toggleComment).\n - Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#comment.toggleBlockComment).\n*/\n\nconst commentKeymap = [{\n  key: \"Mod-/\",\n  run: toggleComment\n}, {\n  key: \"Alt-A\",\n  run: toggleBlockComment\n}];\n\nfunction getConfig(state) {\n  let pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : state.selection.main.head;\n  let data = state.languageDataAt(\"commentTokens\", pos);\n  return data.length ? data[0] : {};\n}\n\nconst SearchMargin = 50;\n/**\nDetermines if the given range is block-commented in the given\nstate.\n*/\n\nfunction findBlockComment(state, _ref2, from, to) {\n  let {\n    open,\n    close\n  } = _ref2;\n  let textBefore = state.sliceDoc(from - SearchMargin, from);\n  let textAfter = state.sliceDoc(to, to + SearchMargin);\n  let spaceBefore = /\\s*$/.exec(textBefore)[0].length,\n      spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n  let beforeOff = textBefore.length - spaceBefore;\n\n  if (textBefore.slice(beforeOff - open.length, beforeOff) == open && textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n    return {\n      open: {\n        pos: from - spaceBefore,\n        margin: spaceBefore && 1\n      },\n      close: {\n        pos: to + spaceAfter,\n        margin: spaceAfter && 1\n      }\n    };\n  }\n\n  let startText, endText;\n\n  if (to - from <= 2 * SearchMargin) {\n    startText = endText = state.sliceDoc(from, to);\n  } else {\n    startText = state.sliceDoc(from, from + SearchMargin);\n    endText = state.sliceDoc(to - SearchMargin, to);\n  }\n\n  let startSpace = /^\\s*/.exec(startText)[0].length,\n      endSpace = /\\s*$/.exec(endText)[0].length;\n  let endOff = endText.length - endSpace - close.length;\n\n  if (startText.slice(startSpace, startSpace + open.length) == open && endText.slice(endOff, endOff + close.length) == close) {\n    return {\n      open: {\n        pos: from + startSpace + open.length,\n        margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0\n      },\n      close: {\n        pos: to - endSpace - close.length,\n        margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0\n      }\n    };\n  }\n\n  return null;\n} // Performs toggle, comment and uncomment of block comments in\n// languages that support them.\n\n\nfunction changeBlockComment(option, ranges, state) {\n  let tokens = ranges.map(r => getConfig(state, r.from).block);\n  if (!tokens.every(c => c)) return null;\n  let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));\n\n  if (option != 2\n  /* Uncomment */\n  && !comments.every(c => c)) {\n    let index = 0;\n    return state.changeByRange(range => {\n      let {\n        open,\n        close\n      } = tokens[index++];\n      if (comments[index]) return {\n        range\n      };\n      let shift = open.length + 1;\n      return {\n        changes: [{\n          from: range.from,\n          insert: open + \" \"\n        }, {\n          from: range.to,\n          insert: \" \" + close\n        }],\n        range: EditorSelection.range(range.anchor + shift, range.head + shift)\n      };\n    });\n  } else if (option != 1\n  /* Comment */\n  && comments.some(c => c)) {\n    let changes = [];\n\n    for (let i = 0, comment; i < comments.length; i++) if (comment = comments[i]) {\n      let token = tokens[i],\n          {\n        open,\n        close\n      } = comment;\n      changes.push({\n        from: open.pos - token.open.length,\n        to: open.pos + open.margin\n      }, {\n        from: close.pos - close.margin,\n        to: close.pos + token.close.length\n      });\n    }\n\n    return {\n      changes\n    };\n  }\n\n  return null;\n} // Performs toggle, comment and uncomment of line comments.\n\n\nfunction changeLineComment(option, ranges, state) {\n  let lines = [];\n  let prevLine = -1;\n\n  for (let {\n    from,\n    to\n  } of ranges) {\n    let startI = lines.length,\n        minIndent = 1e9;\n\n    for (let pos = from; pos <= to;) {\n      let line = state.doc.lineAt(pos);\n\n      if (line.from > prevLine && (from == to || to > line.from)) {\n        prevLine = line.from;\n        let token = getConfig(state, pos).line;\n        if (!token) continue;\n        let indent = /^\\s*/.exec(line.text)[0].length;\n        let empty = indent == line.length;\n        let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n        if (indent < line.text.length && indent < minIndent) minIndent = indent;\n        lines.push({\n          line,\n          comment,\n          token,\n          indent,\n          empty,\n          single: false\n        });\n      }\n\n      pos = line.to + 1;\n    }\n\n    if (minIndent < 1e9) for (let i = startI; i < lines.length; i++) if (lines[i].indent < lines[i].line.text.length) lines[i].indent = minIndent;\n    if (lines.length == startI + 1) lines[startI].single = true;\n  }\n\n  if (option != 2\n  /* Uncomment */\n  && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {\n    let changes = [];\n\n    for (let {\n      line,\n      token,\n      indent,\n      empty,\n      single\n    } of lines) if (single || !empty) changes.push({\n      from: line.from + indent,\n      insert: token + \" \"\n    });\n\n    let changeSet = state.changes(changes);\n    return {\n      changes: changeSet,\n      selection: state.selection.map(changeSet, 1)\n    };\n  } else if (option != 1\n  /* Comment */\n  && lines.some(l => l.comment >= 0)) {\n    let changes = [];\n\n    for (let {\n      line,\n      comment,\n      token\n    } of lines) if (comment >= 0) {\n      let from = line.from + comment,\n          to = from + token.length;\n      if (line.text[to - line.from] == \" \") to++;\n      changes.push({\n        from,\n        to\n      });\n    }\n\n    return {\n      changes\n    };\n  }\n\n  return null;\n}\n\nexport { blockComment, blockUncomment, commentKeymap, lineComment, lineUncomment, toggleBlockComment, toggleComment, toggleLineComment };","map":{"version":3,"sources":["C:/Users/pc/Desktop/live-code-editor/client/node_modules/@codemirror/comment/dist/index.js"],"names":["EditorSelection","toggleComment","target","config","getConfig","state","line","toggleLineComment","block","toggleBlockComment","command","f","option","dispatch","tr","selection","ranges","update","changeLineComment","lineComment","lineUncomment","changeBlockComment","blockComment","blockUncomment","commentKeymap","key","run","pos","main","head","data","languageDataAt","length","SearchMargin","findBlockComment","from","to","open","close","textBefore","sliceDoc","textAfter","spaceBefore","exec","spaceAfter","beforeOff","slice","margin","startText","endText","startSpace","endSpace","endOff","test","charAt","tokens","map","r","every","c","comments","i","index","changeByRange","range","shift","changes","insert","anchor","some","comment","token","push","lines","prevLine","startI","minIndent","doc","lineAt","indent","text","empty","single","l","changeSet"],"mappings":"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","sourcesContent":["import { EditorSelection } from '@codemirror/state';\n\n/**\nComment or uncomment the current selection. Will use line comments\nif available, otherwise falling back to block comments.\n*/\nconst toggleComment = target => {\n    let config = getConfig(target.state);\n    return config.line ? toggleLineComment(target) : config.block ? toggleBlockComment(target) : false;\n};\nfunction command(f, option) {\n    return ({ state, dispatch }) => {\n        let tr = f(option, state.selection.ranges, state);\n        if (!tr)\n            return false;\n        dispatch(state.update(tr));\n        return true;\n    };\n}\n/**\nComment or uncomment the current selection using line comments.\nThe line comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#comment.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\nconst toggleLineComment = /*@__PURE__*/command(changeLineComment, 0 /* Toggle */);\n/**\nComment the current selection using line comments.\n*/\nconst lineComment = /*@__PURE__*/command(changeLineComment, 1 /* Comment */);\n/**\nUncomment the current selection using line comments.\n*/\nconst lineUncomment = /*@__PURE__*/command(changeLineComment, 2 /* Uncomment */);\n/**\nComment or uncomment the current selection using block comments.\nThe block comment syntax is taken from the\n[`commentTokens`](https://codemirror.net/6/docs/ref/#comment.CommentTokens) [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt).\n*/\nconst toggleBlockComment = /*@__PURE__*/command(changeBlockComment, 0 /* Toggle */);\n/**\nComment the current selection using block comments.\n*/\nconst blockComment = /*@__PURE__*/command(changeBlockComment, 1 /* Comment */);\n/**\nUncomment the current selection using block comments.\n*/\nconst blockUncomment = /*@__PURE__*/command(changeBlockComment, 2 /* Uncomment */);\n/**\nDefault key bindings for this package.\n\n - Ctrl-/ (Cmd-/ on macOS): [`toggleComment`](https://codemirror.net/6/docs/ref/#comment.toggleComment).\n - Shift-Alt-a: [`toggleBlockComment`](https://codemirror.net/6/docs/ref/#comment.toggleBlockComment).\n*/\nconst commentKeymap = [\n    { key: \"Mod-/\", run: toggleComment },\n    { key: \"Alt-A\", run: toggleBlockComment }\n];\nfunction getConfig(state, pos = state.selection.main.head) {\n    let data = state.languageDataAt(\"commentTokens\", pos);\n    return data.length ? data[0] : {};\n}\nconst SearchMargin = 50;\n/**\nDetermines if the given range is block-commented in the given\nstate.\n*/\nfunction findBlockComment(state, { open, close }, from, to) {\n    let textBefore = state.sliceDoc(from - SearchMargin, from);\n    let textAfter = state.sliceDoc(to, to + SearchMargin);\n    let spaceBefore = /\\s*$/.exec(textBefore)[0].length, spaceAfter = /^\\s*/.exec(textAfter)[0].length;\n    let beforeOff = textBefore.length - spaceBefore;\n    if (textBefore.slice(beforeOff - open.length, beforeOff) == open &&\n        textAfter.slice(spaceAfter, spaceAfter + close.length) == close) {\n        return { open: { pos: from - spaceBefore, margin: spaceBefore && 1 },\n            close: { pos: to + spaceAfter, margin: spaceAfter && 1 } };\n    }\n    let startText, endText;\n    if (to - from <= 2 * SearchMargin) {\n        startText = endText = state.sliceDoc(from, to);\n    }\n    else {\n        startText = state.sliceDoc(from, from + SearchMargin);\n        endText = state.sliceDoc(to - SearchMargin, to);\n    }\n    let startSpace = /^\\s*/.exec(startText)[0].length, endSpace = /\\s*$/.exec(endText)[0].length;\n    let endOff = endText.length - endSpace - close.length;\n    if (startText.slice(startSpace, startSpace + open.length) == open &&\n        endText.slice(endOff, endOff + close.length) == close) {\n        return { open: { pos: from + startSpace + open.length,\n                margin: /\\s/.test(startText.charAt(startSpace + open.length)) ? 1 : 0 },\n            close: { pos: to - endSpace - close.length,\n                margin: /\\s/.test(endText.charAt(endOff - 1)) ? 1 : 0 } };\n    }\n    return null;\n}\n// Performs toggle, comment and uncomment of block comments in\n// languages that support them.\nfunction changeBlockComment(option, ranges, state) {\n    let tokens = ranges.map(r => getConfig(state, r.from).block);\n    if (!tokens.every(c => c))\n        return null;\n    let comments = ranges.map((r, i) => findBlockComment(state, tokens[i], r.from, r.to));\n    if (option != 2 /* Uncomment */ && !comments.every(c => c)) {\n        let index = 0;\n        return state.changeByRange(range => {\n            let { open, close } = tokens[index++];\n            if (comments[index])\n                return { range };\n            let shift = open.length + 1;\n            return {\n                changes: [{ from: range.from, insert: open + \" \" }, { from: range.to, insert: \" \" + close }],\n                range: EditorSelection.range(range.anchor + shift, range.head + shift)\n            };\n        });\n    }\n    else if (option != 1 /* Comment */ && comments.some(c => c)) {\n        let changes = [];\n        for (let i = 0, comment; i < comments.length; i++)\n            if (comment = comments[i]) {\n                let token = tokens[i], { open, close } = comment;\n                changes.push({ from: open.pos - token.open.length, to: open.pos + open.margin }, { from: close.pos - close.margin, to: close.pos + token.close.length });\n            }\n        return { changes };\n    }\n    return null;\n}\n// Performs toggle, comment and uncomment of line comments.\nfunction changeLineComment(option, ranges, state) {\n    let lines = [];\n    let prevLine = -1;\n    for (let { from, to } of ranges) {\n        let startI = lines.length, minIndent = 1e9;\n        for (let pos = from; pos <= to;) {\n            let line = state.doc.lineAt(pos);\n            if (line.from > prevLine && (from == to || to > line.from)) {\n                prevLine = line.from;\n                let token = getConfig(state, pos).line;\n                if (!token)\n                    continue;\n                let indent = /^\\s*/.exec(line.text)[0].length;\n                let empty = indent == line.length;\n                let comment = line.text.slice(indent, indent + token.length) == token ? indent : -1;\n                if (indent < line.text.length && indent < minIndent)\n                    minIndent = indent;\n                lines.push({ line, comment, token, indent, empty, single: false });\n            }\n            pos = line.to + 1;\n        }\n        if (minIndent < 1e9)\n            for (let i = startI; i < lines.length; i++)\n                if (lines[i].indent < lines[i].line.text.length)\n                    lines[i].indent = minIndent;\n        if (lines.length == startI + 1)\n            lines[startI].single = true;\n    }\n    if (option != 2 /* Uncomment */ && lines.some(l => l.comment < 0 && (!l.empty || l.single))) {\n        let changes = [];\n        for (let { line, token, indent, empty, single } of lines)\n            if (single || !empty)\n                changes.push({ from: line.from + indent, insert: token + \" \" });\n        let changeSet = state.changes(changes);\n        return { changes: changeSet, selection: state.selection.map(changeSet, 1) };\n    }\n    else if (option != 1 /* Comment */ && lines.some(l => l.comment >= 0)) {\n        let changes = [];\n        for (let { line, comment, token } of lines)\n            if (comment >= 0) {\n                let from = line.from + comment, to = from + token.length;\n                if (line.text[to - line.from] == \" \")\n                    to++;\n                changes.push({ from, to });\n            }\n        return { changes };\n    }\n    return null;\n}\n\nexport { blockComment, blockUncomment, commentKeymap, lineComment, lineUncomment, toggleBlockComment, toggleComment, toggleLineComment };\n"]},"metadata":{},"sourceType":"module"}