{"ast":null,"code":"import { EditorSelection, Prec } from '@codemirror/state';\nimport { keymap } from '@codemirror/view';\nimport { defineLanguageFacet, foldNodeProp, indentNodeProp, languageDataProp, Language, LanguageDescription, ParseContext, syntaxTree, LanguageSupport } from '@codemirror/language';\nimport { parser, GFM, Subscript, Superscript, Emoji, MarkdownParser, parseCode } from '@lezer/markdown';\nimport { html } from '@codemirror/lang-html';\nimport { styleTags, tags } from '@codemirror/highlight';\nconst data = /*@__PURE__*/defineLanguageFacet({\n  block: {\n    open: \"<!--\",\n    close: \"-->\"\n  }\n});\nconst commonmark = /*@__PURE__*/parser.configure({\n  props: [/*@__PURE__*/styleTags({\n    \"Blockquote/...\": tags.quote,\n    HorizontalRule: tags.contentSeparator,\n    \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\n    \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\n    \"ATXHeading3/...\": tags.heading3,\n    \"ATXHeading4/...\": tags.heading4,\n    \"ATXHeading5/...\": tags.heading5,\n    \"ATXHeading6/...\": tags.heading6,\n    \"Comment CommentBlock\": tags.comment,\n    Escape: tags.escape,\n    Entity: tags.character,\n    \"Emphasis/...\": tags.emphasis,\n    \"StrongEmphasis/...\": tags.strong,\n    \"Link/... Image/...\": tags.link,\n    \"OrderedList/... BulletList/...\": tags.list,\n    \"BlockQuote/...\": tags.quote,\n    \"InlineCode CodeText\": tags.monospace,\n    URL: tags.url,\n    \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\n    \"CodeInfo LinkLabel\": tags.labelName,\n    LinkTitle: tags.string,\n    Paragraph: tags.content\n  }), /*@__PURE__*/foldNodeProp.add(type => {\n    if (!type.is(\"Block\") || type.is(\"Document\")) return undefined;\n    return (tree, state) => ({\n      from: state.doc.lineAt(tree.from).to,\n      to: tree.to\n    });\n  }), /*@__PURE__*/indentNodeProp.add({\n    Document: () => null\n  }), /*@__PURE__*/languageDataProp.add({\n    Document: data\n  })]\n});\n\nfunction mkLang(parser) {\n  return new Language(data, parser, parser.nodeSet.types.find(t => t.name == \"Document\"));\n}\n/**\nLanguage support for strict CommonMark.\n*/\n\n\nconst commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);\nconst extended = /*@__PURE__*/commonmark.configure([GFM, Subscript, Superscript, Emoji, {\n  props: [/*@__PURE__*/styleTags({\n    \"TableDelimiter SubscriptMark SuperscriptMark StrikethroughMark\": tags.processingInstruction,\n    \"TableHeader/...\": tags.heading,\n    \"Strikethrough/...\": tags.strikethrough,\n    TaskMarker: tags.atom,\n    Task: tags.list,\n    Emoji: tags.character,\n    \"Subscript Superscript\": /*@__PURE__*/tags.special(tags.content),\n    TableCell: tags.content\n  })]\n}]);\n/**\nLanguage support for [GFM](https://github.github.com/gfm/) plus\nsubscript, superscript, and emoji syntax.\n*/\n\nconst markdownLanguage = /*@__PURE__*/mkLang(extended);\n\nfunction getCodeParser(languages, defaultLanguage) {\n  return info => {\n    let found = info && LanguageDescription.matchLanguageName(languages, info, true);\n    if (!found) return defaultLanguage ? defaultLanguage.parser : null;\n    if (found.support) return found.support.language.parser;\n    return ParseContext.getSkippingParser(found.load());\n  };\n}\n\nfunction nodeStart(node, doc) {\n  return doc.sliceString(node.from, node.from + 50);\n}\n\nclass Context {\n  constructor(node, from, to, spaceBefore, spaceAfter, type, item) {\n    this.node = node;\n    this.from = from;\n    this.to = to;\n    this.spaceBefore = spaceBefore;\n    this.spaceAfter = spaceAfter;\n    this.type = type;\n    this.item = item;\n  }\n\n  blank() {\n    let trailing = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let result = this.spaceBefore;\n    if (this.node.name == \"Blockquote\") result += \">\";else for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--) result += \" \";\n    return result + (trailing ? this.spaceAfter : \"\");\n  }\n\n  marker(doc, add) {\n    let number = this.node.name == \"OrderedList\" ? String(+itemNumber(this.item, doc)[2] + add) : \"\";\n    return this.spaceBefore + number + this.type + this.spaceAfter;\n  }\n\n}\n\nfunction getContext(node, line, doc) {\n  let nodes = [];\n\n  for (let cur = node; cur && cur.name != \"Document\"; cur = cur.parent) {\n    if (cur.name == \"ListItem\" || cur.name == \"Blockquote\") nodes.push(cur);\n  }\n\n  let context = [],\n      pos = 0;\n\n  for (let i = nodes.length - 1; i >= 0; i--) {\n    let node = nodes[i],\n        match,\n        start = pos;\n\n    if (node.name == \"Blockquote\" && (match = /^\\s*>( ?)/.exec(line.slice(pos)))) {\n      pos += match[0].length;\n      context.push(new Context(node, start, pos, \"\", match[1], \">\", null));\n    } else if (node.name == \"ListItem\" && node.parent.name == \"OrderedList\" && (match = /^(\\s*)\\d+([.)])(\\s*)/.exec(nodeStart(node, doc)))) {\n      let after = match[3],\n          len = match[0].length;\n\n      if (after.length >= 4) {\n        after = after.slice(0, after.length - 4);\n        len -= 4;\n      }\n\n      pos += len;\n      context.push(new Context(node.parent, start, pos, match[1], after, match[2], node));\n    } else if (node.name == \"ListItem\" && node.parent.name == \"BulletList\" && (match = /^(\\s*)([-+*])(\\s+)/.exec(nodeStart(node, doc)))) {\n      let after = match[3],\n          len = match[0].length;\n\n      if (after.length > 4) {\n        after = after.slice(0, after.length - 4);\n        len -= 4;\n      }\n\n      pos += len;\n      context.push(new Context(node.parent, start, pos, match[1], after, match[2], node));\n    }\n  }\n\n  return context;\n}\n\nfunction itemNumber(item, doc) {\n  return /^(\\s*)(\\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));\n}\n\nfunction renumberList(after, doc, changes) {\n  let offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  for (let prev = -1, node = after;;) {\n    if (node.name == \"ListItem\") {\n      let m = itemNumber(node, doc);\n      let number = +m[2];\n\n      if (prev >= 0) {\n        if (number != prev + 1) return;\n        changes.push({\n          from: node.from + m[1].length,\n          to: node.from + m[0].length,\n          insert: String(prev + 2 + offset)\n        });\n      }\n\n      prev = number;\n    }\n\n    let next = node.nextSibling;\n    if (!next) break;\n    node = next;\n  }\n}\n/**\nThis command, when invoked in Markdown context with cursor\nselection(s), will create a new line with the markup for\nblockquotes and lists that were active on the old line. If the\ncursor was directly after the end of the markup for the old line,\ntrailing whitespace and list markers are removed from that line.\n\nThe command does nothing in non-Markdown context, so it should\nnot be used as the only binding for Enter (even in a Markdown\ndocument, HTML and code regions might use a different language).\n*/\n\n\nconst insertNewlineContinueMarkup = _ref => {\n  let {\n    state,\n    dispatch\n  } = _ref;\n  let tree = syntaxTree(state),\n      {\n    doc\n  } = state;\n  let dont = null,\n      changes = state.changeByRange(range => {\n    if (!range.empty || !markdownLanguage.isActiveAt(state, range.from)) return dont = {\n      range\n    };\n    let pos = range.from,\n        line = doc.lineAt(pos);\n    let context = getContext(tree.resolveInner(pos, -1), line.text, doc);\n\n    while (context.length && context[context.length - 1].from > pos - line.from) context.pop();\n\n    if (!context.length) return dont = {\n      range\n    };\n    let inner = context[context.length - 1];\n    if (inner.to - inner.spaceAfter.length > pos - line.from) return dont = {\n      range\n    }; // Empty line in list\n\n    if (inner.item && pos >= inner.to - inner.spaceAfter.length && !/\\S/.test(line.text.slice(inner.to))) {\n      // First list item or blank line before: delete a level of markup\n      if (inner.node.firstChild.to >= pos || line.from > 0 && !/[^\\s>]/.test(doc.lineAt(line.from - 1).text)) {\n        let next = context.length > 1 ? context[context.length - 2] : null;\n        let delTo,\n            insert = \"\";\n\n        if (next && next.item) {\n          // Re-add marker for the list at the next level\n          delTo = line.from + next.from;\n          insert = next.marker(doc, 1);\n        } else {\n          delTo = line.from + (next ? next.to : 0);\n        }\n\n        let changes = [{\n          from: delTo,\n          to: pos,\n          insert\n        }];\n        if (inner.node.name == \"OrderedList\") renumberList(inner.item, doc, changes, -2);\n        if (next && next.node.name == \"OrderedList\") renumberList(next.item, doc, changes);\n        return {\n          range: EditorSelection.cursor(delTo + insert.length),\n          changes\n        };\n      } else {\n        // Move this line down\n        let insert = \"\";\n\n        for (let i = 0, e = context.length - 2; i <= e; i++) insert += context[i].blank(i < e);\n\n        insert += state.lineBreak;\n        return {\n          range: EditorSelection.cursor(pos + insert.length),\n          changes: {\n            from: line.from,\n            insert\n          }\n        };\n      }\n    }\n\n    let changes = [];\n    if (inner.node.name == \"OrderedList\") renumberList(inner.item, doc, changes);\n    let insert = state.lineBreak;\n    let continued = inner.item && inner.item.from < line.from; // If not dedented\n\n    if (!continued || /^[\\s\\d.)\\-+*>]*/.exec(line.text)[0].length >= inner.to) {\n      for (let i = 0, e = context.length - 1; i <= e; i++) insert += i == e && !continued ? context[i].marker(doc, 1) : context[i].blank();\n    }\n\n    let from = pos;\n\n    while (from > line.from && /\\s/.test(line.text.charAt(from - line.from - 1))) from--;\n\n    changes.push({\n      from,\n      to: pos,\n      insert\n    });\n    return {\n      range: EditorSelection.cursor(from + insert.length),\n      changes\n    };\n  });\n  if (dont) return false;\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"input\"\n  }));\n  return true;\n};\n\nfunction isMark(node) {\n  return node.name == \"QuoteMark\" || node.name == \"ListMark\";\n}\n\nfunction contextNodeForDelete(tree, pos) {\n  let node = tree.resolveInner(pos, -1),\n      scan = pos;\n\n  if (isMark(node)) {\n    scan = node.from;\n    node = node.parent;\n  }\n\n  for (let prev; prev = node.childBefore(scan);) {\n    if (isMark(prev)) {\n      scan = prev.from;\n    } else if (prev.name == \"OrderedList\" || prev.name == \"BulletList\") {\n      node = prev.lastChild;\n      scan = node.to;\n    } else {\n      break;\n    }\n  }\n\n  return node;\n}\n/**\nThis command will, when invoked in a Markdown context with the\ncursor directly after list or blockquote markup, delete one level\nof markup. When the markup is for a list, it will be replaced by\nspaces on the first invocation (a further invocation will delete\nthe spaces), to make it easy to continue a list.\n\nWhen not after Markdown block markup, this command will return\nfalse, so it is intended to be bound alongside other deletion\ncommands, with a higher precedence than the more generic commands.\n*/\n\n\nconst deleteMarkupBackward = _ref2 => {\n  let {\n    state,\n    dispatch\n  } = _ref2;\n  let tree = syntaxTree(state);\n  let dont = null,\n      changes = state.changeByRange(range => {\n    let pos = range.from,\n        {\n      doc\n    } = state;\n\n    if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {\n      let line = doc.lineAt(pos);\n      let context = getContext(contextNodeForDelete(tree, pos), line.text, doc);\n\n      if (context.length) {\n        let inner = context[context.length - 1];\n        let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0); // Delete extra trailing space after markup\n\n        if (pos - line.from > spaceEnd && !/\\S/.test(line.text.slice(spaceEnd, pos - line.from))) return {\n          range: EditorSelection.cursor(line.from + spaceEnd),\n          changes: {\n            from: line.from + spaceEnd,\n            to: pos\n          }\n        };\n\n        if (pos - line.from == spaceEnd) {\n          let start = line.from + inner.from; // Replace a list item marker with blank space\n\n          if (inner.item && inner.node.from < inner.item.from && /\\S/.test(line.text.slice(inner.from, inner.to))) return {\n            range,\n            changes: {\n              from: start,\n              to: line.from + inner.to,\n              insert: inner.blank()\n            }\n          }; // Delete one level of indentation\n\n          if (start < pos) return {\n            range: EditorSelection.cursor(start),\n            changes: {\n              from: start,\n              to: pos\n            }\n          };\n        }\n      }\n    }\n\n    return dont = {\n      range\n    };\n  });\n  if (dont) return false;\n  dispatch(state.update(changes, {\n    scrollIntoView: true,\n    userEvent: \"delete\"\n  }));\n  return true;\n};\n/**\nA small keymap with Markdown-specific bindings. Binds Enter to\n[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)\nand Backspace to\n[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).\n*/\n\n\nconst markdownKeymap = [{\n  key: \"Enter\",\n  run: insertNewlineContinueMarkup\n}, {\n  key: \"Backspace\",\n  run: deleteMarkupBackward\n}];\nconst htmlNoMatch = /*@__PURE__*/html({\n  matchClosingTags: false\n});\n/**\nMarkdown language support.\n*/\n\nfunction markdown() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let {\n    codeLanguages,\n    defaultCodeLanguage,\n    addKeymap = true,\n    base: {\n      parser\n    } = commonmarkLanguage\n  } = config;\n  if (!(parser instanceof MarkdownParser)) throw new RangeError(\"Base parser provided to `markdown` should be a Markdown parser\");\n  let extensions = config.extensions ? [config.extensions] : [];\n  let support = [htmlNoMatch.support],\n      defaultCode;\n\n  if (defaultCodeLanguage instanceof LanguageSupport) {\n    support.push(defaultCodeLanguage.support);\n    defaultCode = defaultCodeLanguage.language;\n  } else if (defaultCodeLanguage) {\n    defaultCode = defaultCodeLanguage;\n  }\n\n  let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages || [], defaultCode) : undefined;\n  extensions.push(parseCode({\n    codeParser,\n    htmlParser: htmlNoMatch.language.parser\n  }));\n  if (addKeymap) support.push(Prec.high(keymap.of(markdownKeymap)));\n  return new LanguageSupport(mkLang(parser.configure(extensions)), support);\n}\n\nexport { commonmarkLanguage, deleteMarkupBackward, insertNewlineContinueMarkup, markdown, markdownKeymap, markdownLanguage };","map":{"version":3,"sources":["C:/Users/pc/Desktop/live-code-editor/client/node_modules/@codemirror/lang-markdown/dist/index.js"],"names":["EditorSelection","Prec","keymap","defineLanguageFacet","foldNodeProp","indentNodeProp","languageDataProp","Language","LanguageDescription","ParseContext","syntaxTree","LanguageSupport","parser","GFM","Subscript","Superscript","Emoji","MarkdownParser","parseCode","html","styleTags","tags","data","block","open","close","commonmark","configure","props","quote","HorizontalRule","contentSeparator","heading1","heading2","heading3","heading4","heading5","heading6","comment","Escape","escape","Entity","character","emphasis","strong","link","list","monospace","URL","url","processingInstruction","labelName","LinkTitle","string","Paragraph","content","add","type","is","undefined","tree","state","from","doc","lineAt","to","Document","mkLang","nodeSet","types","find","t","name","commonmarkLanguage","extended","heading","strikethrough","TaskMarker","atom","Task","special","TableCell","markdownLanguage","getCodeParser","languages","defaultLanguage","info","found","matchLanguageName","support","language","getSkippingParser","load","nodeStart","node","sliceString","Context","constructor","spaceBefore","spaceAfter","item","blank","trailing","result","i","length","marker","number","String","itemNumber","getContext","line","nodes","cur","parent","push","context","pos","match","start","exec","slice","after","len","renumberList","changes","offset","prev","m","insert","next","nextSibling","insertNewlineContinueMarkup","dispatch","dont","changeByRange","range","empty","isActiveAt","resolveInner","text","pop","inner","test","firstChild","delTo","cursor","e","lineBreak","continued","charAt","update","scrollIntoView","userEvent","isMark","contextNodeForDelete","scan","childBefore","lastChild","deleteMarkupBackward","spaceEnd","markdownKeymap","key","run","htmlNoMatch","matchClosingTags","markdown","config","codeLanguages","defaultCodeLanguage","addKeymap","base","RangeError","extensions","defaultCode","codeParser","htmlParser","high","of"],"mappings":"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","sourcesContent":["import { EditorSelection, Prec } from '@codemirror/state';\nimport { keymap } from '@codemirror/view';\nimport { defineLanguageFacet, foldNodeProp, indentNodeProp, languageDataProp, Language, LanguageDescription, ParseContext, syntaxTree, LanguageSupport } from '@codemirror/language';\nimport { parser, GFM, Subscript, Superscript, Emoji, MarkdownParser, parseCode } from '@lezer/markdown';\nimport { html } from '@codemirror/lang-html';\nimport { styleTags, tags } from '@codemirror/highlight';\n\nconst data = /*@__PURE__*/defineLanguageFacet({ block: { open: \"<!--\", close: \"-->\" } });\nconst commonmark = /*@__PURE__*/parser.configure({\n    props: [\n        /*@__PURE__*/styleTags({\n            \"Blockquote/...\": tags.quote,\n            HorizontalRule: tags.contentSeparator,\n            \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\n            \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\n            \"ATXHeading3/...\": tags.heading3,\n            \"ATXHeading4/...\": tags.heading4,\n            \"ATXHeading5/...\": tags.heading5,\n            \"ATXHeading6/...\": tags.heading6,\n            \"Comment CommentBlock\": tags.comment,\n            Escape: tags.escape,\n            Entity: tags.character,\n            \"Emphasis/...\": tags.emphasis,\n            \"StrongEmphasis/...\": tags.strong,\n            \"Link/... Image/...\": tags.link,\n            \"OrderedList/... BulletList/...\": tags.list,\n            \"BlockQuote/...\": tags.quote,\n            \"InlineCode CodeText\": tags.monospace,\n            URL: tags.url,\n            \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\n            \"CodeInfo LinkLabel\": tags.labelName,\n            LinkTitle: tags.string,\n            Paragraph: tags.content\n        }),\n        /*@__PURE__*/foldNodeProp.add(type => {\n            if (!type.is(\"Block\") || type.is(\"Document\"))\n                return undefined;\n            return (tree, state) => ({ from: state.doc.lineAt(tree.from).to, to: tree.to });\n        }),\n        /*@__PURE__*/indentNodeProp.add({\n            Document: () => null\n        }),\n        /*@__PURE__*/languageDataProp.add({\n            Document: data\n        })\n    ]\n});\nfunction mkLang(parser) {\n    return new Language(data, parser, parser.nodeSet.types.find(t => t.name == \"Document\"));\n}\n/**\nLanguage support for strict CommonMark.\n*/\nconst commonmarkLanguage = /*@__PURE__*/mkLang(commonmark);\nconst extended = /*@__PURE__*/commonmark.configure([GFM, Subscript, Superscript, Emoji, {\n        props: [\n            /*@__PURE__*/styleTags({\n                \"TableDelimiter SubscriptMark SuperscriptMark StrikethroughMark\": tags.processingInstruction,\n                \"TableHeader/...\": tags.heading,\n                \"Strikethrough/...\": tags.strikethrough,\n                TaskMarker: tags.atom,\n                Task: tags.list,\n                Emoji: tags.character,\n                \"Subscript Superscript\": /*@__PURE__*/tags.special(tags.content),\n                TableCell: tags.content\n            })\n        ]\n    }]);\n/**\nLanguage support for [GFM](https://github.github.com/gfm/) plus\nsubscript, superscript, and emoji syntax.\n*/\nconst markdownLanguage = /*@__PURE__*/mkLang(extended);\nfunction getCodeParser(languages, defaultLanguage) {\n    return (info) => {\n        let found = info && LanguageDescription.matchLanguageName(languages, info, true);\n        if (!found)\n            return defaultLanguage ? defaultLanguage.parser : null;\n        if (found.support)\n            return found.support.language.parser;\n        return ParseContext.getSkippingParser(found.load());\n    };\n}\n\nfunction nodeStart(node, doc) {\n    return doc.sliceString(node.from, node.from + 50);\n}\nclass Context {\n    constructor(node, from, to, spaceBefore, spaceAfter, type, item) {\n        this.node = node;\n        this.from = from;\n        this.to = to;\n        this.spaceBefore = spaceBefore;\n        this.spaceAfter = spaceAfter;\n        this.type = type;\n        this.item = item;\n    }\n    blank(trailing = true) {\n        let result = this.spaceBefore;\n        if (this.node.name == \"Blockquote\")\n            result += \">\";\n        else\n            for (let i = this.to - this.from - result.length - this.spaceAfter.length; i > 0; i--)\n                result += \" \";\n        return result + (trailing ? this.spaceAfter : \"\");\n    }\n    marker(doc, add) {\n        let number = this.node.name == \"OrderedList\" ? String((+itemNumber(this.item, doc)[2] + add)) : \"\";\n        return this.spaceBefore + number + this.type + this.spaceAfter;\n    }\n}\nfunction getContext(node, line, doc) {\n    let nodes = [];\n    for (let cur = node; cur && cur.name != \"Document\"; cur = cur.parent) {\n        if (cur.name == \"ListItem\" || cur.name == \"Blockquote\")\n            nodes.push(cur);\n    }\n    let context = [], pos = 0;\n    for (let i = nodes.length - 1; i >= 0; i--) {\n        let node = nodes[i], match, start = pos;\n        if (node.name == \"Blockquote\" && (match = /^\\s*>( ?)/.exec(line.slice(pos)))) {\n            pos += match[0].length;\n            context.push(new Context(node, start, pos, \"\", match[1], \">\", null));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"OrderedList\" &&\n            (match = /^(\\s*)\\d+([.)])(\\s*)/.exec(nodeStart(node, doc)))) {\n            let after = match[3], len = match[0].length;\n            if (after.length >= 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            pos += len;\n            context.push(new Context(node.parent, start, pos, match[1], after, match[2], node));\n        }\n        else if (node.name == \"ListItem\" && node.parent.name == \"BulletList\" &&\n            (match = /^(\\s*)([-+*])(\\s+)/.exec(nodeStart(node, doc)))) {\n            let after = match[3], len = match[0].length;\n            if (after.length > 4) {\n                after = after.slice(0, after.length - 4);\n                len -= 4;\n            }\n            pos += len;\n            context.push(new Context(node.parent, start, pos, match[1], after, match[2], node));\n        }\n    }\n    return context;\n}\nfunction itemNumber(item, doc) {\n    return /^(\\s*)(\\d+)(?=[.)])/.exec(doc.sliceString(item.from, item.from + 10));\n}\nfunction renumberList(after, doc, changes, offset = 0) {\n    for (let prev = -1, node = after;;) {\n        if (node.name == \"ListItem\") {\n            let m = itemNumber(node, doc);\n            let number = +m[2];\n            if (prev >= 0) {\n                if (number != prev + 1)\n                    return;\n                changes.push({ from: node.from + m[1].length, to: node.from + m[0].length, insert: String(prev + 2 + offset) });\n            }\n            prev = number;\n        }\n        let next = node.nextSibling;\n        if (!next)\n            break;\n        node = next;\n    }\n}\n/**\nThis command, when invoked in Markdown context with cursor\nselection(s), will create a new line with the markup for\nblockquotes and lists that were active on the old line. If the\ncursor was directly after the end of the markup for the old line,\ntrailing whitespace and list markers are removed from that line.\n\nThe command does nothing in non-Markdown context, so it should\nnot be used as the only binding for Enter (even in a Markdown\ndocument, HTML and code regions might use a different language).\n*/\nconst insertNewlineContinueMarkup = ({ state, dispatch }) => {\n    let tree = syntaxTree(state), { doc } = state;\n    let dont = null, changes = state.changeByRange(range => {\n        if (!range.empty || !markdownLanguage.isActiveAt(state, range.from))\n            return dont = { range };\n        let pos = range.from, line = doc.lineAt(pos);\n        let context = getContext(tree.resolveInner(pos, -1), line.text, doc);\n        while (context.length && context[context.length - 1].from > pos - line.from)\n            context.pop();\n        if (!context.length)\n            return dont = { range };\n        let inner = context[context.length - 1];\n        if (inner.to - inner.spaceAfter.length > pos - line.from)\n            return dont = { range };\n        // Empty line in list\n        if (inner.item && pos >= (inner.to - inner.spaceAfter.length) && !/\\S/.test(line.text.slice(inner.to))) {\n            // First list item or blank line before: delete a level of markup\n            if (inner.node.firstChild.to >= pos ||\n                line.from > 0 && !/[^\\s>]/.test(doc.lineAt(line.from - 1).text)) {\n                let next = context.length > 1 ? context[context.length - 2] : null;\n                let delTo, insert = \"\";\n                if (next && next.item) { // Re-add marker for the list at the next level\n                    delTo = line.from + next.from;\n                    insert = next.marker(doc, 1);\n                }\n                else {\n                    delTo = line.from + (next ? next.to : 0);\n                }\n                let changes = [{ from: delTo, to: pos, insert }];\n                if (inner.node.name == \"OrderedList\")\n                    renumberList(inner.item, doc, changes, -2);\n                if (next && next.node.name == \"OrderedList\")\n                    renumberList(next.item, doc, changes);\n                return { range: EditorSelection.cursor(delTo + insert.length), changes };\n            }\n            else { // Move this line down\n                let insert = \"\";\n                for (let i = 0, e = context.length - 2; i <= e; i++)\n                    insert += context[i].blank(i < e);\n                insert += state.lineBreak;\n                return { range: EditorSelection.cursor(pos + insert.length), changes: { from: line.from, insert } };\n            }\n        }\n        let changes = [];\n        if (inner.node.name == \"OrderedList\")\n            renumberList(inner.item, doc, changes);\n        let insert = state.lineBreak;\n        let continued = inner.item && inner.item.from < line.from;\n        // If not dedented\n        if (!continued || /^[\\s\\d.)\\-+*>]*/.exec(line.text)[0].length >= inner.to) {\n            for (let i = 0, e = context.length - 1; i <= e; i++)\n                insert += i == e && !continued ? context[i].marker(doc, 1) : context[i].blank();\n        }\n        let from = pos;\n        while (from > line.from && /\\s/.test(line.text.charAt(from - line.from - 1)))\n            from--;\n        changes.push({ from, to: pos, insert });\n        return { range: EditorSelection.cursor(from + insert.length), changes };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"input\" }));\n    return true;\n};\nfunction isMark(node) {\n    return node.name == \"QuoteMark\" || node.name == \"ListMark\";\n}\nfunction contextNodeForDelete(tree, pos) {\n    let node = tree.resolveInner(pos, -1), scan = pos;\n    if (isMark(node)) {\n        scan = node.from;\n        node = node.parent;\n    }\n    for (let prev; prev = node.childBefore(scan);) {\n        if (isMark(prev)) {\n            scan = prev.from;\n        }\n        else if (prev.name == \"OrderedList\" || prev.name == \"BulletList\") {\n            node = prev.lastChild;\n            scan = node.to;\n        }\n        else {\n            break;\n        }\n    }\n    return node;\n}\n/**\nThis command will, when invoked in a Markdown context with the\ncursor directly after list or blockquote markup, delete one level\nof markup. When the markup is for a list, it will be replaced by\nspaces on the first invocation (a further invocation will delete\nthe spaces), to make it easy to continue a list.\n\nWhen not after Markdown block markup, this command will return\nfalse, so it is intended to be bound alongside other deletion\ncommands, with a higher precedence than the more generic commands.\n*/\nconst deleteMarkupBackward = ({ state, dispatch }) => {\n    let tree = syntaxTree(state);\n    let dont = null, changes = state.changeByRange(range => {\n        let pos = range.from, { doc } = state;\n        if (range.empty && markdownLanguage.isActiveAt(state, range.from)) {\n            let line = doc.lineAt(pos);\n            let context = getContext(contextNodeForDelete(tree, pos), line.text, doc);\n            if (context.length) {\n                let inner = context[context.length - 1];\n                let spaceEnd = inner.to - inner.spaceAfter.length + (inner.spaceAfter ? 1 : 0);\n                // Delete extra trailing space after markup\n                if (pos - line.from > spaceEnd && !/\\S/.test(line.text.slice(spaceEnd, pos - line.from)))\n                    return { range: EditorSelection.cursor(line.from + spaceEnd),\n                        changes: { from: line.from + spaceEnd, to: pos } };\n                if (pos - line.from == spaceEnd) {\n                    let start = line.from + inner.from;\n                    // Replace a list item marker with blank space\n                    if (inner.item && inner.node.from < inner.item.from && /\\S/.test(line.text.slice(inner.from, inner.to)))\n                        return { range, changes: { from: start, to: line.from + inner.to, insert: inner.blank() } };\n                    // Delete one level of indentation\n                    if (start < pos)\n                        return { range: EditorSelection.cursor(start), changes: { from: start, to: pos } };\n                }\n            }\n        }\n        return dont = { range };\n    });\n    if (dont)\n        return false;\n    dispatch(state.update(changes, { scrollIntoView: true, userEvent: \"delete\" }));\n    return true;\n};\n\n/**\nA small keymap with Markdown-specific bindings. Binds Enter to\n[`insertNewlineContinueMarkup`](https://codemirror.net/6/docs/ref/#lang-markdown.insertNewlineContinueMarkup)\nand Backspace to\n[`deleteMarkupBackward`](https://codemirror.net/6/docs/ref/#lang-markdown.deleteMarkupBackward).\n*/\nconst markdownKeymap = [\n    { key: \"Enter\", run: insertNewlineContinueMarkup },\n    { key: \"Backspace\", run: deleteMarkupBackward }\n];\nconst htmlNoMatch = /*@__PURE__*/html({ matchClosingTags: false });\n/**\nMarkdown language support.\n*/\nfunction markdown(config = {}) {\n    let { codeLanguages, defaultCodeLanguage, addKeymap = true, base: { parser } = commonmarkLanguage } = config;\n    if (!(parser instanceof MarkdownParser))\n        throw new RangeError(\"Base parser provided to `markdown` should be a Markdown parser\");\n    let extensions = config.extensions ? [config.extensions] : [];\n    let support = [htmlNoMatch.support], defaultCode;\n    if (defaultCodeLanguage instanceof LanguageSupport) {\n        support.push(defaultCodeLanguage.support);\n        defaultCode = defaultCodeLanguage.language;\n    }\n    else if (defaultCodeLanguage) {\n        defaultCode = defaultCodeLanguage;\n    }\n    let codeParser = codeLanguages || defaultCode ? getCodeParser(codeLanguages || [], defaultCode) : undefined;\n    extensions.push(parseCode({ codeParser, htmlParser: htmlNoMatch.language.parser }));\n    if (addKeymap)\n        support.push(Prec.high(keymap.of(markdownKeymap)));\n    return new LanguageSupport(mkLang(parser.configure(extensions)), support);\n}\n\nexport { commonmarkLanguage, deleteMarkupBackward, insertNewlineContinueMarkup, markdown, markdownKeymap, markdownLanguage };\n"]},"metadata":{},"sourceType":"module"}