{"ast":null,"code":"import { EditorView, ViewPlugin, BlockType, PluginField, Direction } from '@codemirror/view';\nimport { RangeSet, RangeValue } from '@codemirror/rangeset';\nimport { MapMode, Facet, combineConfig } from '@codemirror/state';\n/**\nA gutter marker represents a bit of information attached to a line\nin a specific gutter. Your own custom markers have to extend this\nclass.\n*/\n\nclass GutterMarker extends RangeValue {\n  /**\n  @internal\n  */\n  compare(other) {\n    return this == other || this.constructor == other.constructor && this.eq(other);\n  }\n  /**\n  Compare this marker to another marker of the same type.\n  */\n\n\n  eq(other) {\n    return false;\n  }\n  /**\n  Called if the marker has a `toDOM` method and its representation\n  was removed from a gutter.\n  */\n\n\n  destroy(dom) {}\n\n}\n\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.toDOM = undefined;\nGutterMarker.prototype.mapMode = MapMode.TrackBefore;\nGutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;\nGutterMarker.prototype.point = true;\n/**\nFacet used to add a class to all gutter elements for a given line.\nMarkers given to this facet should _only_ define an\n[`elementclass`](https://codemirror.net/6/docs/ref/#gutter.GutterMarker.elementClass), not a\n[`toDOM`](https://codemirror.net/6/docs/ref/#gutter.GutterMarker.toDOM) (or the marker will appear\nin all gutters for the line).\n*/\n\nconst gutterLineClass = /*@__PURE__*/Facet.define();\nconst defaults = {\n  class: \"\",\n  renderEmptyElements: false,\n  elementStyle: \"\",\n  markers: () => RangeSet.empty,\n  lineMarker: () => null,\n  lineMarkerChange: null,\n  initialSpacer: null,\n  updateSpacer: null,\n  domEventHandlers: {}\n};\nconst activeGutters = /*@__PURE__*/Facet.define();\n/**\nDefine an editor gutter. The order in which the gutters appear is\ndetermined by their extension priority.\n*/\n\nfunction gutter(config) {\n  return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];\n}\n\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-gutters\": {\n    display: \"flex\",\n    height: \"100%\",\n    boxSizing: \"border-box\",\n    left: 0,\n    zIndex: 200\n  },\n  \"&light .cm-gutters\": {\n    backgroundColor: \"#f5f5f5\",\n    color: \"#999\",\n    borderRight: \"1px solid #ddd\"\n  },\n  \"&dark .cm-gutters\": {\n    backgroundColor: \"#333338\",\n    color: \"#ccc\"\n  },\n  \".cm-gutter\": {\n    display: \"flex !important\",\n    flexDirection: \"column\",\n    flexShrink: 0,\n    boxSizing: \"border-box\",\n    minHeight: \"100%\",\n    overflow: \"hidden\"\n  },\n  \".cm-gutterElement\": {\n    boxSizing: \"border-box\"\n  },\n  \".cm-lineNumbers .cm-gutterElement\": {\n    padding: \"0 3px 0 5px\",\n    minWidth: \"20px\",\n    textAlign: \"right\",\n    whiteSpace: \"nowrap\"\n  },\n  \"&light .cm-activeLineGutter\": {\n    backgroundColor: \"#e2f2ff\"\n  },\n  \"&dark .cm-activeLineGutter\": {\n    backgroundColor: \"#222227\"\n  }\n});\nconst unfixGutters = /*@__PURE__*/Facet.define({\n  combine: values => values.some(x => x)\n});\n/**\nThe gutter-drawing plugin is automatically enabled when you add a\ngutter, but you can use this function to explicitly configure it.\n\nUnless `fixed` is explicitly set to `false`, the gutters are\nfixed, meaning they don't scroll along with the content\nhorizontally (except on Internet Explorer, which doesn't support\nCSS [`position:\nsticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).\n*/\n\nfunction gutters(config) {\n  let result = [gutterView, baseTheme];\n  if (config && config.fixed === false) result.push(unfixGutters.of(true));\n  return result;\n}\n\nconst gutterView = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.prevViewport = view.viewport;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-gutters\";\n    this.dom.setAttribute(\"aria-hidden\", \"true\");\n    this.dom.style.minHeight = this.view.contentHeight + \"px\";\n    this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));\n\n    for (let gutter of this.gutters) this.dom.appendChild(gutter.dom);\n\n    this.fixed = !view.state.facet(unfixGutters);\n\n    if (this.fixed) {\n      // FIXME IE11 fallback, which doesn't support position: sticky,\n      // by using position: relative + event handlers that realign the\n      // gutter (or just force fixed=false on IE11?)\n      this.dom.style.position = \"sticky\";\n    }\n\n    this.syncGutters(false);\n    view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n  }\n\n  update(update) {\n    if (this.updateGutters(update)) {\n      // Detach during sync when the viewport changed significantly\n      // (such as during scrolling), since for large updates that is\n      // faster.\n      let vpA = this.prevViewport,\n          vpB = update.view.viewport;\n      let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);\n      this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);\n    }\n\n    if (update.geometryChanged) this.dom.style.minHeight = this.view.contentHeight + \"px\";\n\n    if (this.view.state.facet(unfixGutters) != !this.fixed) {\n      this.fixed = !this.fixed;\n      this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n    }\n\n    this.prevViewport = update.view.viewport;\n  }\n\n  syncGutters(detach) {\n    let after = this.dom.nextSibling;\n    if (detach) this.dom.remove();\n    let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);\n    let classSet = [];\n    let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));\n\n    for (let line of this.view.viewportLineBlocks) {\n      let text;\n\n      if (Array.isArray(line.type)) {\n        for (let b of line.type) if (b.type == BlockType.Text) {\n          text = b;\n          break;\n        }\n      } else {\n        text = line.type == BlockType.Text ? line : undefined;\n      }\n\n      if (!text) continue;\n      if (classSet.length) classSet = [];\n      advanceCursor(lineClasses, classSet, line.from);\n\n      for (let cx of contexts) cx.line(this.view, text, classSet);\n    }\n\n    for (let cx of contexts) cx.finish();\n\n    if (detach) this.view.scrollDOM.insertBefore(this.dom, after);\n  }\n\n  updateGutters(update) {\n    let prev = update.startState.facet(activeGutters),\n        cur = update.state.facet(activeGutters);\n    let change = update.docChanged || update.heightChanged || update.viewportChanged || !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);\n\n    if (prev == cur) {\n      for (let gutter of this.gutters) if (gutter.update(update)) change = true;\n    } else {\n      change = true;\n      let gutters = [];\n\n      for (let conf of cur) {\n        let known = prev.indexOf(conf);\n\n        if (known < 0) {\n          gutters.push(new SingleGutterView(this.view, conf));\n        } else {\n          this.gutters[known].update(update);\n          gutters.push(this.gutters[known]);\n        }\n      }\n\n      for (let g of this.gutters) {\n        g.dom.remove();\n        if (gutters.indexOf(g) < 0) g.destroy();\n      }\n\n      for (let g of gutters) this.dom.appendChild(g.dom);\n\n      this.gutters = gutters;\n    }\n\n    return change;\n  }\n\n  destroy() {\n    for (let view of this.gutters) view.destroy();\n\n    this.dom.remove();\n  }\n\n}, {\n  provide: /*@__PURE__*/PluginField.scrollMargins.from(value => {\n    if (value.gutters.length == 0 || !value.fixed) return null;\n    return value.view.textDirection == Direction.LTR ? {\n      left: value.dom.offsetWidth\n    } : {\n      right: value.dom.offsetWidth\n    };\n  })\n});\n\nfunction asArray(val) {\n  return Array.isArray(val) ? val : [val];\n}\n\nfunction advanceCursor(cursor, collect, pos) {\n  while (cursor.value && cursor.from <= pos) {\n    if (cursor.from == pos) collect.push(cursor.value);\n    cursor.next();\n  }\n}\n\nclass UpdateContext {\n  constructor(gutter, viewport, height) {\n    this.gutter = gutter;\n    this.height = height;\n    this.localMarkers = [];\n    this.i = 0;\n    this.cursor = RangeSet.iter(gutter.markers, viewport.from);\n  }\n\n  line(view, line, extraMarkers) {\n    if (this.localMarkers.length) this.localMarkers = [];\n    advanceCursor(this.cursor, this.localMarkers, line.from);\n    let localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;\n    let forLine = this.gutter.config.lineMarker(view, line, localMarkers);\n    if (forLine) localMarkers.unshift(forLine);\n    let gutter = this.gutter;\n    if (localMarkers.length == 0 && !gutter.config.renderEmptyElements) return;\n    let above = line.top - this.height;\n\n    if (this.i == gutter.elements.length) {\n      let newElt = new GutterElement(view, line.height, above, localMarkers);\n      gutter.elements.push(newElt);\n      gutter.dom.appendChild(newElt.dom);\n    } else {\n      gutter.elements[this.i].update(view, line.height, above, localMarkers);\n    }\n\n    this.height = line.bottom;\n    this.i++;\n  }\n\n  finish() {\n    let gutter = this.gutter;\n\n    while (gutter.elements.length > this.i) {\n      let last = gutter.elements.pop();\n      gutter.dom.removeChild(last.dom);\n      last.destroy();\n    }\n  }\n\n}\n\nclass SingleGutterView {\n  constructor(view, config) {\n    this.view = view;\n    this.config = config;\n    this.elements = [];\n    this.spacer = null;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"cm-gutter\" + (this.config.class ? \" \" + this.config.class : \"\");\n\n    for (let prop in config.domEventHandlers) {\n      this.dom.addEventListener(prop, event => {\n        let line = view.lineBlockAtHeight(event.clientY - view.documentTop);\n        if (config.domEventHandlers[prop](view, line, event)) event.preventDefault();\n      });\n    }\n\n    this.markers = asArray(config.markers(view));\n\n    if (config.initialSpacer) {\n      this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);\n      this.dom.appendChild(this.spacer.dom);\n      this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n    }\n  }\n\n  update(update) {\n    let prevMarkers = this.markers;\n    this.markers = asArray(this.config.markers(update.view));\n\n    if (this.spacer && this.config.updateSpacer) {\n      let updated = this.config.updateSpacer(this.spacer.markers[0], update);\n      if (updated != this.spacer.markers[0]) this.spacer.update(update.view, 0, 0, [updated]);\n    }\n\n    let vp = update.view.viewport;\n    return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);\n  }\n\n  destroy() {\n    for (let elt of this.elements) elt.destroy();\n  }\n\n}\n\nclass GutterElement {\n  constructor(view, height, above, markers) {\n    this.height = -1;\n    this.above = 0;\n    this.markers = [];\n    this.dom = document.createElement(\"div\");\n    this.update(view, height, above, markers);\n  }\n\n  update(view, height, above, markers) {\n    if (this.height != height) this.dom.style.height = (this.height = height) + \"px\";\n    if (this.above != above) this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\n    if (!sameMarkers(this.markers, markers)) this.setMarkers(view, markers);\n  }\n\n  setMarkers(view, markers) {\n    let cls = \"cm-gutterElement\",\n        domPos = this.dom.firstChild;\n\n    for (let iNew = 0, iOld = 0;;) {\n      let skipTo = iOld,\n          marker = iNew < markers.length ? markers[iNew++] : null,\n          matched = false;\n\n      if (marker) {\n        let c = marker.elementClass;\n        if (c) cls += \" \" + c;\n\n        for (let i = iOld; i < this.markers.length; i++) if (this.markers[i].compare(marker)) {\n          skipTo = i;\n          matched = true;\n          break;\n        }\n      } else {\n        skipTo = this.markers.length;\n      }\n\n      while (iOld < skipTo) {\n        let next = this.markers[iOld++];\n\n        if (next.toDOM) {\n          next.destroy(domPos);\n          let after = domPos.nextSibling;\n          domPos.remove();\n          domPos = after;\n        }\n      }\n\n      if (!marker) break;\n\n      if (marker.toDOM) {\n        if (matched) domPos = domPos.nextSibling;else this.dom.insertBefore(marker.toDOM(view), domPos);\n      }\n\n      if (matched) iOld++;\n    }\n\n    this.dom.className = cls;\n    this.markers = markers;\n  }\n\n  destroy() {\n    this.setMarkers(null, []); // First argument not used unless creating markers\n  }\n\n}\n\nfunction sameMarkers(a, b) {\n  if (a.length != b.length) return false;\n\n  for (let i = 0; i < a.length; i++) if (!a[i].compare(b[i])) return false;\n\n  return true;\n}\n/**\nFacet used to provide markers to the line number gutter.\n*/\n\n\nconst lineNumberMarkers = /*@__PURE__*/Facet.define();\nconst lineNumberConfig = /*@__PURE__*/Facet.define({\n  combine(values) {\n    return combineConfig(values, {\n      formatNumber: String,\n      domEventHandlers: {}\n    }, {\n      domEventHandlers(a, b) {\n        let result = Object.assign({}, a);\n\n        for (let event in b) {\n          let exists = result[event],\n              add = b[event];\n          result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;\n        }\n\n        return result;\n      }\n\n    });\n  }\n\n});\n\nclass NumberMarker extends GutterMarker {\n  constructor(number) {\n    super();\n    this.number = number;\n  }\n\n  eq(other) {\n    return this.number == other.number;\n  }\n\n  toDOM() {\n    return document.createTextNode(this.number);\n  }\n\n}\n\nfunction formatNumber(view, number) {\n  return view.state.facet(lineNumberConfig).formatNumber(number, view.state);\n}\n\nconst lineNumberGutter = /*@__PURE__*/activeGutters.compute([lineNumberConfig], state => ({\n  class: \"cm-lineNumbers\",\n  renderEmptyElements: false,\n\n  markers(view) {\n    return view.state.facet(lineNumberMarkers);\n  },\n\n  lineMarker(view, line, others) {\n    if (others.some(m => m.toDOM)) return null;\n    return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));\n  },\n\n  lineMarkerChange: update => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),\n\n  initialSpacer(view) {\n    return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));\n  },\n\n  updateSpacer(spacer, update) {\n    let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));\n    return max == spacer.number ? spacer : new NumberMarker(max);\n  },\n\n  domEventHandlers: state.facet(lineNumberConfig).domEventHandlers\n}));\n/**\nCreate a line number gutter extension.\n*/\n\nfunction lineNumbers() {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return [lineNumberConfig.of(config), gutters(), lineNumberGutter];\n}\n\nfunction maxLineNumber(lines) {\n  let last = 9;\n\n  while (last < lines) last = last * 10 + 9;\n\n  return last;\n}\n\nconst activeLineGutterMarker = /*@__PURE__*/new class extends GutterMarker {\n  constructor() {\n    super(...arguments);\n    this.elementClass = \"cm-activeLineGutter\";\n  }\n\n}();\nconst activeLineGutterHighlighter = /*@__PURE__*/gutterLineClass.compute([\"selection\"], state => {\n  let marks = [],\n      last = -1;\n\n  for (let range of state.selection.ranges) if (range.empty) {\n    let linePos = state.doc.lineAt(range.head).from;\n\n    if (linePos > last) {\n      last = linePos;\n      marks.push(activeLineGutterMarker.range(linePos));\n    }\n  }\n\n  return RangeSet.of(marks);\n});\n/**\nReturns an extension that adds a `cm-activeLineGutter` class to\nall gutter elements on the [active\nline](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).\n*/\n\nfunction highlightActiveLineGutter() {\n  return activeLineGutterHighlighter;\n}\n\nexport { GutterMarker, gutter, gutterLineClass, gutters, highlightActiveLineGutter, lineNumberMarkers, lineNumbers };","map":{"version":3,"sources":["C:/Users/pc/Desktop/live-code-editor/client/node_modules/@codemirror/gutter/dist/index.js"],"names":["EditorView","ViewPlugin","BlockType","PluginField","Direction","RangeSet","RangeValue","MapMode","Facet","combineConfig","GutterMarker","compare","other","constructor","eq","destroy","dom","prototype","elementClass","toDOM","undefined","mapMode","TrackBefore","startSide","endSide","point","gutterLineClass","define","defaults","class","renderEmptyElements","elementStyle","markers","empty","lineMarker","lineMarkerChange","initialSpacer","updateSpacer","domEventHandlers","activeGutters","gutter","config","gutters","of","Object","assign","baseTheme","display","height","boxSizing","left","zIndex","backgroundColor","color","borderRight","flexDirection","flexShrink","minHeight","overflow","padding","minWidth","textAlign","whiteSpace","unfixGutters","combine","values","some","x","result","gutterView","fixed","push","fromClass","view","prevViewport","viewport","document","createElement","className","setAttribute","style","contentHeight","state","facet","map","conf","SingleGutterView","appendChild","position","syncGutters","scrollDOM","insertBefore","contentDOM","update","updateGutters","vpA","vpB","vpOverlap","Math","min","to","max","from","geometryChanged","detach","after","nextSibling","remove","lineClasses","iter","classSet","contexts","UpdateContext","documentPadding","top","line","viewportLineBlocks","text","Array","isArray","type","b","Text","length","advanceCursor","cx","finish","prev","startState","cur","change","docChanged","heightChanged","viewportChanged","known","indexOf","g","provide","scrollMargins","value","textDirection","LTR","offsetWidth","right","asArray","val","cursor","collect","pos","next","localMarkers","i","extraMarkers","concat","forLine","unshift","above","elements","newElt","GutterElement","bottom","last","pop","removeChild","spacer","prop","addEventListener","event","lineBlockAtHeight","clientY","documentTop","preventDefault","cssText","prevMarkers","updated","vp","elt","marginTop","sameMarkers","setMarkers","cls","domPos","firstChild","iNew","iOld","skipTo","marker","matched","c","a","lineNumberMarkers","lineNumberConfig","formatNumber","String","exists","add","NumberMarker","number","createTextNode","lineNumberGutter","compute","others","m","doc","lineAt","maxLineNumber","lines","lineNumbers","activeLineGutterMarker","arguments","activeLineGutterHighlighter","marks","range","selection","ranges","linePos","head","highlightActiveLineGutter"],"mappings":"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","sourcesContent":["import { EditorView, ViewPlugin, BlockType, PluginField, Direction } from '@codemirror/view';\nimport { RangeSet, RangeValue } from '@codemirror/rangeset';\nimport { MapMode, Facet, combineConfig } from '@codemirror/state';\n\n/**\nA gutter marker represents a bit of information attached to a line\nin a specific gutter. Your own custom markers have to extend this\nclass.\n*/\nclass GutterMarker extends RangeValue {\n    /**\n    @internal\n    */\n    compare(other) {\n        return this == other || this.constructor == other.constructor && this.eq(other);\n    }\n    /**\n    Compare this marker to another marker of the same type.\n    */\n    eq(other) { return false; }\n    /**\n    Called if the marker has a `toDOM` method and its representation\n    was removed from a gutter.\n    */\n    destroy(dom) { }\n}\nGutterMarker.prototype.elementClass = \"\";\nGutterMarker.prototype.toDOM = undefined;\nGutterMarker.prototype.mapMode = MapMode.TrackBefore;\nGutterMarker.prototype.startSide = GutterMarker.prototype.endSide = -1;\nGutterMarker.prototype.point = true;\n/**\nFacet used to add a class to all gutter elements for a given line.\nMarkers given to this facet should _only_ define an\n[`elementclass`](https://codemirror.net/6/docs/ref/#gutter.GutterMarker.elementClass), not a\n[`toDOM`](https://codemirror.net/6/docs/ref/#gutter.GutterMarker.toDOM) (or the marker will appear\nin all gutters for the line).\n*/\nconst gutterLineClass = /*@__PURE__*/Facet.define();\nconst defaults = {\n    class: \"\",\n    renderEmptyElements: false,\n    elementStyle: \"\",\n    markers: () => RangeSet.empty,\n    lineMarker: () => null,\n    lineMarkerChange: null,\n    initialSpacer: null,\n    updateSpacer: null,\n    domEventHandlers: {}\n};\nconst activeGutters = /*@__PURE__*/Facet.define();\n/**\nDefine an editor gutter. The order in which the gutters appear is\ndetermined by their extension priority.\n*/\nfunction gutter(config) {\n    return [gutters(), activeGutters.of(Object.assign(Object.assign({}, defaults), config))];\n}\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-gutters\": {\n        display: \"flex\",\n        height: \"100%\",\n        boxSizing: \"border-box\",\n        left: 0,\n        zIndex: 200\n    },\n    \"&light .cm-gutters\": {\n        backgroundColor: \"#f5f5f5\",\n        color: \"#999\",\n        borderRight: \"1px solid #ddd\"\n    },\n    \"&dark .cm-gutters\": {\n        backgroundColor: \"#333338\",\n        color: \"#ccc\"\n    },\n    \".cm-gutter\": {\n        display: \"flex !important\",\n        flexDirection: \"column\",\n        flexShrink: 0,\n        boxSizing: \"border-box\",\n        minHeight: \"100%\",\n        overflow: \"hidden\"\n    },\n    \".cm-gutterElement\": {\n        boxSizing: \"border-box\"\n    },\n    \".cm-lineNumbers .cm-gutterElement\": {\n        padding: \"0 3px 0 5px\",\n        minWidth: \"20px\",\n        textAlign: \"right\",\n        whiteSpace: \"nowrap\"\n    },\n    \"&light .cm-activeLineGutter\": {\n        backgroundColor: \"#e2f2ff\"\n    },\n    \"&dark .cm-activeLineGutter\": {\n        backgroundColor: \"#222227\"\n    }\n});\nconst unfixGutters = /*@__PURE__*/Facet.define({\n    combine: values => values.some(x => x)\n});\n/**\nThe gutter-drawing plugin is automatically enabled when you add a\ngutter, but you can use this function to explicitly configure it.\n\nUnless `fixed` is explicitly set to `false`, the gutters are\nfixed, meaning they don't scroll along with the content\nhorizontally (except on Internet Explorer, which doesn't support\nCSS [`position:\nsticky`](https://developer.mozilla.org/en-US/docs/Web/CSS/position#sticky)).\n*/\nfunction gutters(config) {\n    let result = [\n        gutterView,\n        baseTheme\n    ];\n    if (config && config.fixed === false)\n        result.push(unfixGutters.of(true));\n    return result;\n}\nconst gutterView = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.prevViewport = view.viewport;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutters\";\n        this.dom.setAttribute(\"aria-hidden\", \"true\");\n        this.dom.style.minHeight = this.view.contentHeight + \"px\";\n        this.gutters = view.state.facet(activeGutters).map(conf => new SingleGutterView(view, conf));\n        for (let gutter of this.gutters)\n            this.dom.appendChild(gutter.dom);\n        this.fixed = !view.state.facet(unfixGutters);\n        if (this.fixed) {\n            // FIXME IE11 fallback, which doesn't support position: sticky,\n            // by using position: relative + event handlers that realign the\n            // gutter (or just force fixed=false on IE11?)\n            this.dom.style.position = \"sticky\";\n        }\n        this.syncGutters(false);\n        view.scrollDOM.insertBefore(this.dom, view.contentDOM);\n    }\n    update(update) {\n        if (this.updateGutters(update)) {\n            // Detach during sync when the viewport changed significantly\n            // (such as during scrolling), since for large updates that is\n            // faster.\n            let vpA = this.prevViewport, vpB = update.view.viewport;\n            let vpOverlap = Math.min(vpA.to, vpB.to) - Math.max(vpA.from, vpB.from);\n            this.syncGutters(vpOverlap < (vpB.to - vpB.from) * 0.8);\n        }\n        if (update.geometryChanged)\n            this.dom.style.minHeight = this.view.contentHeight + \"px\";\n        if (this.view.state.facet(unfixGutters) != !this.fixed) {\n            this.fixed = !this.fixed;\n            this.dom.style.position = this.fixed ? \"sticky\" : \"\";\n        }\n        this.prevViewport = update.view.viewport;\n    }\n    syncGutters(detach) {\n        let after = this.dom.nextSibling;\n        if (detach)\n            this.dom.remove();\n        let lineClasses = RangeSet.iter(this.view.state.facet(gutterLineClass), this.view.viewport.from);\n        let classSet = [];\n        let contexts = this.gutters.map(gutter => new UpdateContext(gutter, this.view.viewport, -this.view.documentPadding.top));\n        for (let line of this.view.viewportLineBlocks) {\n            let text;\n            if (Array.isArray(line.type)) {\n                for (let b of line.type)\n                    if (b.type == BlockType.Text) {\n                        text = b;\n                        break;\n                    }\n            }\n            else {\n                text = line.type == BlockType.Text ? line : undefined;\n            }\n            if (!text)\n                continue;\n            if (classSet.length)\n                classSet = [];\n            advanceCursor(lineClasses, classSet, line.from);\n            for (let cx of contexts)\n                cx.line(this.view, text, classSet);\n        }\n        for (let cx of contexts)\n            cx.finish();\n        if (detach)\n            this.view.scrollDOM.insertBefore(this.dom, after);\n    }\n    updateGutters(update) {\n        let prev = update.startState.facet(activeGutters), cur = update.state.facet(activeGutters);\n        let change = update.docChanged || update.heightChanged || update.viewportChanged ||\n            !RangeSet.eq(update.startState.facet(gutterLineClass), update.state.facet(gutterLineClass), update.view.viewport.from, update.view.viewport.to);\n        if (prev == cur) {\n            for (let gutter of this.gutters)\n                if (gutter.update(update))\n                    change = true;\n        }\n        else {\n            change = true;\n            let gutters = [];\n            for (let conf of cur) {\n                let known = prev.indexOf(conf);\n                if (known < 0) {\n                    gutters.push(new SingleGutterView(this.view, conf));\n                }\n                else {\n                    this.gutters[known].update(update);\n                    gutters.push(this.gutters[known]);\n                }\n            }\n            for (let g of this.gutters) {\n                g.dom.remove();\n                if (gutters.indexOf(g) < 0)\n                    g.destroy();\n            }\n            for (let g of gutters)\n                this.dom.appendChild(g.dom);\n            this.gutters = gutters;\n        }\n        return change;\n    }\n    destroy() {\n        for (let view of this.gutters)\n            view.destroy();\n        this.dom.remove();\n    }\n}, {\n    provide: /*@__PURE__*/PluginField.scrollMargins.from(value => {\n        if (value.gutters.length == 0 || !value.fixed)\n            return null;\n        return value.view.textDirection == Direction.LTR ? { left: value.dom.offsetWidth } : { right: value.dom.offsetWidth };\n    })\n});\nfunction asArray(val) { return (Array.isArray(val) ? val : [val]); }\nfunction advanceCursor(cursor, collect, pos) {\n    while (cursor.value && cursor.from <= pos) {\n        if (cursor.from == pos)\n            collect.push(cursor.value);\n        cursor.next();\n    }\n}\nclass UpdateContext {\n    constructor(gutter, viewport, height) {\n        this.gutter = gutter;\n        this.height = height;\n        this.localMarkers = [];\n        this.i = 0;\n        this.cursor = RangeSet.iter(gutter.markers, viewport.from);\n    }\n    line(view, line, extraMarkers) {\n        if (this.localMarkers.length)\n            this.localMarkers = [];\n        advanceCursor(this.cursor, this.localMarkers, line.from);\n        let localMarkers = extraMarkers.length ? this.localMarkers.concat(extraMarkers) : this.localMarkers;\n        let forLine = this.gutter.config.lineMarker(view, line, localMarkers);\n        if (forLine)\n            localMarkers.unshift(forLine);\n        let gutter = this.gutter;\n        if (localMarkers.length == 0 && !gutter.config.renderEmptyElements)\n            return;\n        let above = line.top - this.height;\n        if (this.i == gutter.elements.length) {\n            let newElt = new GutterElement(view, line.height, above, localMarkers);\n            gutter.elements.push(newElt);\n            gutter.dom.appendChild(newElt.dom);\n        }\n        else {\n            gutter.elements[this.i].update(view, line.height, above, localMarkers);\n        }\n        this.height = line.bottom;\n        this.i++;\n    }\n    finish() {\n        let gutter = this.gutter;\n        while (gutter.elements.length > this.i) {\n            let last = gutter.elements.pop();\n            gutter.dom.removeChild(last.dom);\n            last.destroy();\n        }\n    }\n}\nclass SingleGutterView {\n    constructor(view, config) {\n        this.view = view;\n        this.config = config;\n        this.elements = [];\n        this.spacer = null;\n        this.dom = document.createElement(\"div\");\n        this.dom.className = \"cm-gutter\" + (this.config.class ? \" \" + this.config.class : \"\");\n        for (let prop in config.domEventHandlers) {\n            this.dom.addEventListener(prop, (event) => {\n                let line = view.lineBlockAtHeight(event.clientY - view.documentTop);\n                if (config.domEventHandlers[prop](view, line, event))\n                    event.preventDefault();\n            });\n        }\n        this.markers = asArray(config.markers(view));\n        if (config.initialSpacer) {\n            this.spacer = new GutterElement(view, 0, 0, [config.initialSpacer(view)]);\n            this.dom.appendChild(this.spacer.dom);\n            this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\";\n        }\n    }\n    update(update) {\n        let prevMarkers = this.markers;\n        this.markers = asArray(this.config.markers(update.view));\n        if (this.spacer && this.config.updateSpacer) {\n            let updated = this.config.updateSpacer(this.spacer.markers[0], update);\n            if (updated != this.spacer.markers[0])\n                this.spacer.update(update.view, 0, 0, [updated]);\n        }\n        let vp = update.view.viewport;\n        return !RangeSet.eq(this.markers, prevMarkers, vp.from, vp.to) ||\n            (this.config.lineMarkerChange ? this.config.lineMarkerChange(update) : false);\n    }\n    destroy() {\n        for (let elt of this.elements)\n            elt.destroy();\n    }\n}\nclass GutterElement {\n    constructor(view, height, above, markers) {\n        this.height = -1;\n        this.above = 0;\n        this.markers = [];\n        this.dom = document.createElement(\"div\");\n        this.update(view, height, above, markers);\n    }\n    update(view, height, above, markers) {\n        if (this.height != height)\n            this.dom.style.height = (this.height = height) + \"px\";\n        if (this.above != above)\n            this.dom.style.marginTop = (this.above = above) ? above + \"px\" : \"\";\n        if (!sameMarkers(this.markers, markers))\n            this.setMarkers(view, markers);\n    }\n    setMarkers(view, markers) {\n        let cls = \"cm-gutterElement\", domPos = this.dom.firstChild;\n        for (let iNew = 0, iOld = 0;;) {\n            let skipTo = iOld, marker = iNew < markers.length ? markers[iNew++] : null, matched = false;\n            if (marker) {\n                let c = marker.elementClass;\n                if (c)\n                    cls += \" \" + c;\n                for (let i = iOld; i < this.markers.length; i++)\n                    if (this.markers[i].compare(marker)) {\n                        skipTo = i;\n                        matched = true;\n                        break;\n                    }\n            }\n            else {\n                skipTo = this.markers.length;\n            }\n            while (iOld < skipTo) {\n                let next = this.markers[iOld++];\n                if (next.toDOM) {\n                    next.destroy(domPos);\n                    let after = domPos.nextSibling;\n                    domPos.remove();\n                    domPos = after;\n                }\n            }\n            if (!marker)\n                break;\n            if (marker.toDOM) {\n                if (matched)\n                    domPos = domPos.nextSibling;\n                else\n                    this.dom.insertBefore(marker.toDOM(view), domPos);\n            }\n            if (matched)\n                iOld++;\n        }\n        this.dom.className = cls;\n        this.markers = markers;\n    }\n    destroy() {\n        this.setMarkers(null, []); // First argument not used unless creating markers\n    }\n}\nfunction sameMarkers(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].compare(b[i]))\n            return false;\n    return true;\n}\n/**\nFacet used to provide markers to the line number gutter.\n*/\nconst lineNumberMarkers = /*@__PURE__*/Facet.define();\nconst lineNumberConfig = /*@__PURE__*/Facet.define({\n    combine(values) {\n        return combineConfig(values, { formatNumber: String, domEventHandlers: {} }, {\n            domEventHandlers(a, b) {\n                let result = Object.assign({}, a);\n                for (let event in b) {\n                    let exists = result[event], add = b[event];\n                    result[event] = exists ? (view, line, event) => exists(view, line, event) || add(view, line, event) : add;\n                }\n                return result;\n            }\n        });\n    }\n});\nclass NumberMarker extends GutterMarker {\n    constructor(number) {\n        super();\n        this.number = number;\n    }\n    eq(other) { return this.number == other.number; }\n    toDOM() { return document.createTextNode(this.number); }\n}\nfunction formatNumber(view, number) {\n    return view.state.facet(lineNumberConfig).formatNumber(number, view.state);\n}\nconst lineNumberGutter = /*@__PURE__*/activeGutters.compute([lineNumberConfig], state => ({\n    class: \"cm-lineNumbers\",\n    renderEmptyElements: false,\n    markers(view) { return view.state.facet(lineNumberMarkers); },\n    lineMarker(view, line, others) {\n        if (others.some(m => m.toDOM))\n            return null;\n        return new NumberMarker(formatNumber(view, view.state.doc.lineAt(line.from).number));\n    },\n    lineMarkerChange: update => update.startState.facet(lineNumberConfig) != update.state.facet(lineNumberConfig),\n    initialSpacer(view) {\n        return new NumberMarker(formatNumber(view, maxLineNumber(view.state.doc.lines)));\n    },\n    updateSpacer(spacer, update) {\n        let max = formatNumber(update.view, maxLineNumber(update.view.state.doc.lines));\n        return max == spacer.number ? spacer : new NumberMarker(max);\n    },\n    domEventHandlers: state.facet(lineNumberConfig).domEventHandlers\n}));\n/**\nCreate a line number gutter extension.\n*/\nfunction lineNumbers(config = {}) {\n    return [\n        lineNumberConfig.of(config),\n        gutters(),\n        lineNumberGutter\n    ];\n}\nfunction maxLineNumber(lines) {\n    let last = 9;\n    while (last < lines)\n        last = last * 10 + 9;\n    return last;\n}\nconst activeLineGutterMarker = /*@__PURE__*/new class extends GutterMarker {\n    constructor() {\n        super(...arguments);\n        this.elementClass = \"cm-activeLineGutter\";\n    }\n};\nconst activeLineGutterHighlighter = /*@__PURE__*/gutterLineClass.compute([\"selection\"], state => {\n    let marks = [], last = -1;\n    for (let range of state.selection.ranges)\n        if (range.empty) {\n            let linePos = state.doc.lineAt(range.head).from;\n            if (linePos > last) {\n                last = linePos;\n                marks.push(activeLineGutterMarker.range(linePos));\n            }\n        }\n    return RangeSet.of(marks);\n});\n/**\nReturns an extension that adds a `cm-activeLineGutter` class to\nall gutter elements on the [active\nline](https://codemirror.net/6/docs/ref/#view.highlightActiveLine).\n*/\nfunction highlightActiveLineGutter() {\n    return activeLineGutterHighlighter;\n}\n\nexport { GutterMarker, gutter, gutterLineClass, gutters, highlightActiveLineGutter, lineNumberMarkers, lineNumbers };\n"]},"metadata":{},"sourceType":"module"}