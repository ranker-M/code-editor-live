{"ast":null,"code":"import { parser } from '@lezer/cpp';\nimport { LRLanguage, indentNodeProp, continuedIndent, flatIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { styleTags, tags } from '@codemirror/highlight';\n/**\nA language provider based on the [Lezer C++\nparser](https://github.com/lezer-parser/cpp), extended with\nhighlighting and indentation information.\n*/\n\nconst cppLanguage = /*@__PURE__*/LRLanguage.define({\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/indentNodeProp.add({\n      IfStatement: /*@__PURE__*/continuedIndent({\n        except: /^\\s*({|else\\b)/\n      }),\n      TryStatement: /*@__PURE__*/continuedIndent({\n        except: /^\\s*({|catch)\\b/\n      }),\n      LabeledStatement: flatIndent,\n      CaseStatement: context => context.baseIndent + context.unit,\n      BlockComment: () => -1,\n      Statement: /*@__PURE__*/continuedIndent({\n        except: /^{/\n      })\n    }), /*@__PURE__*/foldNodeProp.add({\n      \"DeclarationList CompoundStatement EnumeratorList FieldDeclarationList InitializerList\": foldInside,\n\n      BlockComment(tree) {\n        return {\n          from: tree.from + 2,\n          to: tree.to - 2\n        };\n      }\n\n    }), /*@__PURE__*/styleTags({\n      \"typedef struct union enum class typename decltype auto template operator friend noexcept namespace using __attribute__ __declspec __based\": tags.definitionKeyword,\n      \"extern MsCallModifier MsPointerModifier extern static register inline const volatile restrict _Atomic mutable constexpr virtual explicit VirtualSpecifier Access\": tags.modifier,\n      \"if else switch for while do case default return break continue goto throw try catch\": tags.controlKeyword,\n      \"new sizeof delete static_assert\": tags.operatorKeyword,\n      \"NULL nullptr\": tags.null,\n      this: tags.self,\n      \"True False\": tags.bool,\n      \"TypeSize PrimitiveType\": /*@__PURE__*/tags.standard(tags.typeName),\n      TypeIdentifier: tags.typeName,\n      FieldIdentifier: tags.propertyName,\n      \"CallExpression/FieldExpression/FieldIdentifier\": /*@__PURE__*/tags.function(tags.propertyName),\n      StatementIdentifier: tags.labelName,\n      Identifier: tags.variableName,\n      \"CallExpression/Identifier\": /*@__PURE__*/tags.function(tags.variableName),\n      \"CallExpression/ScopedIdentifier/Identifier\": /*@__PURE__*/tags.function(tags.variableName),\n      DestructorName: tags.name,\n      NamespaceIdentifier: tags.namespace,\n      OperatorName: tags.operator,\n      ArithOp: tags.arithmeticOperator,\n      LogicOp: tags.logicOperator,\n      BitOp: tags.bitwiseOperator,\n      CompareOp: tags.compareOperator,\n      AssignOp: tags.definitionOperator,\n      UpdateOp: tags.updateOperator,\n      LineComment: tags.lineComment,\n      BlockComment: tags.blockComment,\n      Number: tags.number,\n      String: tags.string,\n      \"RawString SystemLibString\": /*@__PURE__*/tags.special(tags.string),\n      CharLiteral: tags.character,\n      EscapeSequence: tags.escape,\n      PreProcArg: tags.meta,\n      \"PreprocDirectiveName #include #ifdef #ifndef #if #define #else #endif #elif\": tags.processingInstruction,\n      MacroName: /*@__PURE__*/tags.special(tags.name),\n      \"( )\": tags.paren,\n      \"[ ]\": tags.squareBracket,\n      \"{ }\": tags.brace,\n      \"< >\": tags.angleBracket,\n      \". ->\": tags.derefOperator,\n      \", ;\": tags.separator\n    })]\n  }),\n  languageData: {\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    },\n    indentOnInput: /^\\s*(?:case |default:|\\{|\\})$/\n  }\n});\n/**\nLanguage support for C++.\n*/\n\nfunction cpp() {\n  return new LanguageSupport(cppLanguage);\n}\n\nexport { cpp, cppLanguage };","map":{"version":3,"sources":["C:/Users/pc/Desktop/live-code-editor/client/node_modules/@codemirror/lang-cpp/dist/index.js"],"names":["parser","LRLanguage","indentNodeProp","continuedIndent","flatIndent","foldNodeProp","foldInside","LanguageSupport","styleTags","tags","cppLanguage","define","configure","props","add","IfStatement","except","TryStatement","LabeledStatement","CaseStatement","context","baseIndent","unit","BlockComment","Statement","tree","from","to","definitionKeyword","modifier","controlKeyword","operatorKeyword","null","this","self","bool","standard","typeName","TypeIdentifier","FieldIdentifier","propertyName","function","StatementIdentifier","labelName","Identifier","variableName","DestructorName","name","NamespaceIdentifier","namespace","OperatorName","operator","ArithOp","arithmeticOperator","LogicOp","logicOperator","BitOp","bitwiseOperator","CompareOp","compareOperator","AssignOp","definitionOperator","UpdateOp","updateOperator","LineComment","lineComment","blockComment","Number","number","String","string","special","CharLiteral","character","EscapeSequence","escape","PreProcArg","meta","processingInstruction","MacroName","paren","squareBracket","brace","angleBracket","derefOperator","separator","languageData","commentTokens","line","block","open","close","indentOnInput","cpp"],"mappings":"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","sourcesContent":["import { parser } from '@lezer/cpp';\nimport { LRLanguage, indentNodeProp, continuedIndent, flatIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { styleTags, tags } from '@codemirror/highlight';\n\n/**\nA language provider based on the [Lezer C++\nparser](https://github.com/lezer-parser/cpp), extended with\nhighlighting and indentation information.\n*/\nconst cppLanguage = /*@__PURE__*/LRLanguage.define({\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                IfStatement: /*@__PURE__*/continuedIndent({ except: /^\\s*({|else\\b)/ }),\n                TryStatement: /*@__PURE__*/continuedIndent({ except: /^\\s*({|catch)\\b/ }),\n                LabeledStatement: flatIndent,\n                CaseStatement: context => context.baseIndent + context.unit,\n                BlockComment: () => -1,\n                Statement: /*@__PURE__*/continuedIndent({ except: /^{/ })\n            }),\n            /*@__PURE__*/foldNodeProp.add({\n                \"DeclarationList CompoundStatement EnumeratorList FieldDeclarationList InitializerList\": foldInside,\n                BlockComment(tree) { return { from: tree.from + 2, to: tree.to - 2 }; }\n            }),\n            /*@__PURE__*/styleTags({\n                \"typedef struct union enum class typename decltype auto template operator friend noexcept namespace using __attribute__ __declspec __based\": tags.definitionKeyword,\n                \"extern MsCallModifier MsPointerModifier extern static register inline const volatile restrict _Atomic mutable constexpr virtual explicit VirtualSpecifier Access\": tags.modifier,\n                \"if else switch for while do case default return break continue goto throw try catch\": tags.controlKeyword,\n                \"new sizeof delete static_assert\": tags.operatorKeyword,\n                \"NULL nullptr\": tags.null,\n                this: tags.self,\n                \"True False\": tags.bool,\n                \"TypeSize PrimitiveType\": /*@__PURE__*/tags.standard(tags.typeName),\n                TypeIdentifier: tags.typeName,\n                FieldIdentifier: tags.propertyName,\n                \"CallExpression/FieldExpression/FieldIdentifier\": /*@__PURE__*/tags.function(tags.propertyName),\n                StatementIdentifier: tags.labelName,\n                Identifier: tags.variableName,\n                \"CallExpression/Identifier\": /*@__PURE__*/tags.function(tags.variableName),\n                \"CallExpression/ScopedIdentifier/Identifier\": /*@__PURE__*/tags.function(tags.variableName),\n                DestructorName: tags.name,\n                NamespaceIdentifier: tags.namespace,\n                OperatorName: tags.operator,\n                ArithOp: tags.arithmeticOperator,\n                LogicOp: tags.logicOperator,\n                BitOp: tags.bitwiseOperator,\n                CompareOp: tags.compareOperator,\n                AssignOp: tags.definitionOperator,\n                UpdateOp: tags.updateOperator,\n                LineComment: tags.lineComment,\n                BlockComment: tags.blockComment,\n                Number: tags.number,\n                String: tags.string,\n                \"RawString SystemLibString\": /*@__PURE__*/tags.special(tags.string),\n                CharLiteral: tags.character,\n                EscapeSequence: tags.escape,\n                PreProcArg: tags.meta,\n                \"PreprocDirectiveName #include #ifdef #ifndef #if #define #else #endif #elif\": tags.processingInstruction,\n                MacroName: /*@__PURE__*/tags.special(tags.name),\n                \"( )\": tags.paren,\n                \"[ ]\": tags.squareBracket,\n                \"{ }\": tags.brace,\n                \"< >\": tags.angleBracket,\n                \". ->\": tags.derefOperator,\n                \", ;\": tags.separator\n            })\n        ]\n    }),\n    languageData: {\n        commentTokens: { line: \"//\", block: { open: \"/*\", close: \"*/\" } },\n        indentOnInput: /^\\s*(?:case |default:|\\{|\\})$/\n    }\n});\n/**\nLanguage support for C++.\n*/\nfunction cpp() {\n    return new LanguageSupport(cppLanguage);\n}\n\nexport { cpp, cppLanguage };\n"]},"metadata":{},"sourceType":"module"}