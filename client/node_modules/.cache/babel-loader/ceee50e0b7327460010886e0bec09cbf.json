{"ast":null,"code":"import { MapMode } from '@codemirror/state';\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/\n\nclass RangeValue {\n  /**\n  Compare this value with another value. The default\n  implementation compares by identity.\n  */\n  eq(other) {\n    return this == other;\n  }\n  /**\n  Create a [range](https://codemirror.net/6/docs/ref/#rangeset.Range) with this value.\n  */\n\n\n  range(from) {\n    let to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : from;\n    return new Range(from, to, this);\n  }\n\n}\n\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/\n\nclass Range {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  The range's start position.\n  */\n  from,\n  /**\n  Its end position.\n  */\n  to,\n  /**\n  The value associated with this range.\n  */\n  value) {\n    this.from = from;\n    this.to = to;\n    this.value = value;\n  }\n\n}\n\nfunction cmpRange(a, b) {\n  return a.from - b.from || a.value.startSide - b.value.startSide;\n}\n\nclass Chunk {\n  constructor(from, to, value, // Chunks are marked with the largest point that occurs\n  // in them (or -1 for no points), so that scans that are\n  // only interested in points (such as the\n  // heightmap-related logic) can skip range-only chunks.\n  maxPoint) {\n    this.from = from;\n    this.to = to;\n    this.value = value;\n    this.maxPoint = maxPoint;\n  }\n\n  get length() {\n    return this.to[this.to.length - 1];\n  } // Find the index of the given position and side. Use the ranges'\n  // `from` pos when `end == false`, `to` when `end == true`.\n\n\n  findIndex(pos, side, end) {\n    let startAt = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let arr = end ? this.to : this.from;\n\n    for (let lo = startAt, hi = arr.length;;) {\n      if (lo == hi) return lo;\n      let mid = lo + hi >> 1;\n      let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;\n      if (mid == lo) return diff >= 0 ? lo : hi;\n      if (diff >= 0) hi = mid;else lo = mid + 1;\n    }\n  }\n\n  between(offset, from, to, f) {\n    for (let i = this.findIndex(from, -1000000000\n    /* Far */\n    , true), e = this.findIndex(to, 1000000000\n    /* Far */\n    , false, i); i < e; i++) if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false) return false;\n  }\n\n  map(offset, changes) {\n    let value = [],\n        from = [],\n        to = [],\n        newPos = -1,\n        maxPoint = -1;\n\n    for (let i = 0; i < this.value.length; i++) {\n      let val = this.value[i],\n          curFrom = this.from[i] + offset,\n          curTo = this.to[i] + offset,\n          newFrom,\n          newTo;\n\n      if (curFrom == curTo) {\n        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n        if (mapped == null) continue;\n        newFrom = newTo = mapped;\n\n        if (val.startSide != val.endSide) {\n          newTo = changes.mapPos(curFrom, val.endSide);\n          if (newTo < newFrom) continue;\n        }\n      } else {\n        newFrom = changes.mapPos(curFrom, val.startSide);\n        newTo = changes.mapPos(curTo, val.endSide);\n        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;\n      }\n\n      if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;\n      if (newPos < 0) newPos = newFrom;\n      if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);\n      value.push(val);\n      from.push(newFrom - newPos);\n      to.push(newTo - newPos);\n    }\n\n    return {\n      mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,\n      pos: newPos\n    };\n  }\n\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#rangeset.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.update). This is an immutable data\nstructure.\n*/\n\n\nclass RangeSet {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  @internal\n  */\n  chunkPos,\n  /**\n  @internal\n  */\n  chunk) {\n    let nextLayer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : RangeSet.empty;\n    let\n    /**\n    @internal\n    */\n    maxPoint = arguments.length > 3 ? arguments[3] : undefined;\n    this.chunkPos = chunkPos;\n    this.chunk = chunk;\n    this.nextLayer = nextLayer;\n    this.maxPoint = maxPoint;\n  }\n  /**\n  @internal\n  */\n\n\n  get length() {\n    let last = this.chunk.length - 1;\n    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n  }\n  /**\n  The number of ranges in the set.\n  */\n\n\n  get size() {\n    if (this.isEmpty) return 0;\n    let size = this.nextLayer.size;\n\n    for (let chunk of this.chunk) size += chunk.value.length;\n\n    return size;\n  }\n  /**\n  @internal\n  */\n\n\n  chunkEnd(index) {\n    return this.chunkPos[index] + this.chunk[index].length;\n  }\n  /**\n  Update the range set, optionally adding new ranges or filtering\n  out existing ones.\n  \n  (The extra type parameter is just there as a kludge to work\n  around TypeScript variance issues that prevented `RangeSet<X>`\n  from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n  `Y`.)\n  */\n\n\n  update(updateSpec) {\n    let {\n      add = [],\n      sort = false,\n      filterFrom = 0,\n      filterTo = this.length\n    } = updateSpec;\n    let filter = updateSpec.filter;\n    if (add.length == 0 && !filter) return this;\n    if (sort) add.slice().sort(cmpRange);\n    if (this.isEmpty) return add.length ? RangeSet.of(add) : this;\n    let cur = new LayerCursor(this, null, -1).goto(0),\n        i = 0,\n        spill = [];\n    let builder = new RangeSetBuilder();\n\n    while (cur.value || i < add.length) {\n      if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n        let range = add[i++];\n        if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);\n      } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n        cur.nextChunk();\n      } else {\n        if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n          if (!builder.addInner(cur.from, cur.to, cur.value)) spill.push(new Range(cur.from, cur.to, cur.value));\n        }\n\n        cur.next();\n      }\n    }\n\n    return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty : this.nextLayer.update({\n      add: spill,\n      filter,\n      filterFrom,\n      filterTo\n    }));\n  }\n  /**\n  Map this range set through a set of changes, return the new set.\n  */\n\n\n  map(changes) {\n    if (changes.length == 0 || this.isEmpty) return this;\n    let chunks = [],\n        chunkPos = [],\n        maxPoint = -1;\n\n    for (let i = 0; i < this.chunk.length; i++) {\n      let start = this.chunkPos[i],\n          chunk = this.chunk[i];\n      let touch = changes.touchesRange(start, start + chunk.length);\n\n      if (touch === false) {\n        maxPoint = Math.max(maxPoint, chunk.maxPoint);\n        chunks.push(chunk);\n        chunkPos.push(changes.mapPos(start));\n      } else if (touch === true) {\n        let {\n          mapped,\n          pos\n        } = chunk.map(start, changes);\n\n        if (mapped) {\n          maxPoint = Math.max(maxPoint, mapped.maxPoint);\n          chunks.push(mapped);\n          chunkPos.push(pos);\n        }\n      }\n    }\n\n    let next = this.nextLayer.map(changes);\n    return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);\n  }\n  /**\n  Iterate over the ranges that touch the region `from` to `to`,\n  calling `f` for each. There is no guarantee that the ranges will\n  be reported in any specific order. When the callback returns\n  `false`, iteration stops.\n  */\n\n\n  between(from, to, f) {\n    if (this.isEmpty) return;\n\n    for (let i = 0; i < this.chunk.length; i++) {\n      let start = this.chunkPos[i],\n          chunk = this.chunk[i];\n      if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;\n    }\n\n    this.nextLayer.between(from, to, f);\n  }\n  /**\n  Iterate over the ranges in this set, in order, including all\n  ranges that end at or after `from`.\n  */\n\n\n  iter() {\n    let from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return HeapCursor.from([this]).goto(from);\n  }\n  /**\n  @internal\n  */\n\n\n  get isEmpty() {\n    return this.nextLayer == this;\n  }\n  /**\n  Iterate over the ranges in a collection of sets, in order,\n  starting from `from`.\n  */\n\n\n  static iter(sets) {\n    let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return HeapCursor.from(sets).goto(from);\n  }\n  /**\n  Iterate over two groups of sets, calling methods on `comparator`\n  to notify it of possible differences.\n  */\n\n\n  static compare(oldSets, newSets,\n  /**\n  This indicates how the underlying data changed between these\n  ranges, and is needed to synchronize the iteration. `from` and\n  `to` are coordinates in the _new_ space, after these changes.\n  */\n  textDiff, comparator) {\n    let minPointSize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n    let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n    let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n    let sharedChunks = findSharedChunks(a, b, textDiff);\n    let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n    let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n    if (textDiff.empty && textDiff.length == 0) compare(sideA, 0, sideB, 0, 0, comparator);\n  }\n  /**\n  Compare the contents of two groups of range sets, returning true\n  if they are equivalent in the given range.\n  */\n\n\n  static eq(oldSets, newSets) {\n    let from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let to = arguments.length > 3 ? arguments[3] : undefined;\n    if (to == null) to = 1000000000\n    /* Far */\n    ;\n    let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);\n    let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);\n    if (a.length != b.length) return false;\n    if (!a.length) return true;\n    let sharedChunks = findSharedChunks(a, b);\n    let sideA = new SpanCursor(a, sharedChunks, 0).goto(from),\n        sideB = new SpanCursor(b, sharedChunks, 0).goto(from);\n\n    for (;;) {\n      if (sideA.to != sideB.to || !sameValues(sideA.active, sideB.active) || sideA.point && (!sideB.point || !sideA.point.eq(sideB.point))) return false;\n      if (sideA.to > to) return true;\n      sideA.next();\n      sideB.next();\n    }\n  }\n  /**\n  Iterate over a group of range sets at the same time, notifying\n  the iterator about the ranges covering every given piece of\n  content. Returns the open count (see\n  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#rangeset.SpanIterator.span)) at the end\n  of the iteration.\n  */\n\n\n  static spans(sets, from, to, iterator) {\n    let minPointSize = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : -1;\n\n    var _a;\n\n    let cursor = new SpanCursor(sets, null, minPointSize, (_a = iterator.filterPoint) === null || _a === void 0 ? void 0 : _a.bind(iterator)).goto(from),\n        pos = from;\n    let open = cursor.openStart;\n\n    for (;;) {\n      let curTo = Math.min(cursor.to, to);\n\n      if (cursor.point) {\n        iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);\n        open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);\n      } else if (curTo > pos) {\n        iterator.span(pos, curTo, cursor.active, open);\n        open = cursor.openEnd(curTo);\n      }\n\n      if (cursor.to > to) break;\n      pos = cursor.to;\n      cursor.next();\n    }\n\n    return open;\n  }\n  /**\n  Create a range set for the given range or array of ranges. By\n  default, this expects the ranges to be _sorted_ (by start\n  position and, if two start at the same position,\n  `value.startSide`). You can pass `true` as second argument to\n  cause the method to sort them.\n  */\n\n\n  static of(ranges) {\n    let sort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let build = new RangeSetBuilder();\n\n    for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges) build.add(range.from, range.to, range.value);\n\n    return build.finish();\n  }\n\n}\n/**\nThe empty set of ranges.\n*/\n\n\nRangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);\n\nfunction lazySort(ranges) {\n  if (ranges.length > 1) for (let prev = ranges[0], i = 1; i < ranges.length; i++) {\n    let cur = ranges[i];\n    if (cmpRange(prev, cur) > 0) return ranges.slice().sort(cmpRange);\n    prev = cur;\n  }\n  return ranges;\n}\n\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#rangeset.Range) objects.\n*/\n\nclass RangeSetBuilder {\n  /**\n  Create an empty builder.\n  */\n  constructor() {\n    this.chunks = [];\n    this.chunkPos = [];\n    this.chunkStart = -1;\n    this.last = null;\n    this.lastFrom = -1000000000\n    /* Far */\n    ;\n    this.lastTo = -1000000000\n    /* Far */\n    ;\n    this.from = [];\n    this.to = [];\n    this.value = [];\n    this.maxPoint = -1;\n    this.setMaxPoint = -1;\n    this.nextLayer = null;\n  }\n\n  finishChunk(newArrays) {\n    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n    this.chunkPos.push(this.chunkStart);\n    this.chunkStart = -1;\n    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n    this.maxPoint = -1;\n\n    if (newArrays) {\n      this.from = [];\n      this.to = [];\n      this.value = [];\n    }\n  }\n  /**\n  Add a range. Ranges should be added in sorted (by `from` and\n  `value.startSide`) order.\n  */\n\n\n  add(from, to, value) {\n    if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);\n  }\n  /**\n  @internal\n  */\n\n\n  addInner(from, to, value) {\n    let diff = from - this.lastTo || value.startSide - this.last.endSide;\n    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n    if (diff < 0) return false;\n    if (this.from.length == 250\n    /* ChunkSize */\n    ) this.finishChunk(true);\n    if (this.chunkStart < 0) this.chunkStart = from;\n    this.from.push(from - this.chunkStart);\n    this.to.push(to - this.chunkStart);\n    this.last = value;\n    this.lastFrom = from;\n    this.lastTo = to;\n    this.value.push(value);\n    if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);\n    return true;\n  }\n  /**\n  @internal\n  */\n\n\n  addChunk(from, chunk) {\n    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;\n    if (this.from.length) this.finishChunk(true);\n    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n    this.chunks.push(chunk);\n    this.chunkPos.push(from);\n    let last = chunk.value.length - 1;\n    this.last = chunk.value[last];\n    this.lastFrom = chunk.from[last] + from;\n    this.lastTo = chunk.to[last] + from;\n    return true;\n  }\n  /**\n  Finish the range set. Returns the new set. The builder can't be\n  used anymore after this has been called.\n  */\n\n\n  finish() {\n    return this.finishInner(RangeSet.empty);\n  }\n  /**\n  @internal\n  */\n\n\n  finishInner(next) {\n    if (this.from.length) this.finishChunk(false);\n    if (this.chunks.length == 0) return next;\n    let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n    this.from = null; // Make sure further `add` calls produce errors\n\n    return result;\n  }\n\n}\n\nfunction findSharedChunks(a, b, textDiff) {\n  let inA = new Map();\n\n  for (let set of a) for (let i = 0; i < set.chunk.length; i++) if (set.chunk[i].maxPoint <= 0) inA.set(set.chunk[i], set.chunkPos[i]);\n\n  let shared = new Set();\n\n  for (let set of b) for (let i = 0; i < set.chunk.length; i++) {\n    let known = inA.get(set.chunk[i]);\n    if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] && !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length))) shared.add(set.chunk[i]);\n  }\n\n  return shared;\n}\n\nclass LayerCursor {\n  constructor(layer, skip, minPoint) {\n    let rank = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    this.layer = layer;\n    this.skip = skip;\n    this.minPoint = minPoint;\n    this.rank = rank;\n  }\n\n  get startSide() {\n    return this.value ? this.value.startSide : 0;\n  }\n\n  get endSide() {\n    return this.value ? this.value.endSide : 0;\n  }\n\n  goto(pos) {\n    let side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1000000000;\n    this.chunkIndex = this.rangeIndex = 0;\n    this.gotoInner(pos, side, false);\n    return this;\n  }\n\n  gotoInner(pos, side, forward) {\n    while (this.chunkIndex < this.layer.chunk.length) {\n      let next = this.layer.chunk[this.chunkIndex];\n      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;\n      this.chunkIndex++;\n      forward = false;\n    }\n\n    if (this.chunkIndex < this.layer.chunk.length) {\n      let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);\n      if (!forward || this.rangeIndex < rangeIndex) this.setRangeIndex(rangeIndex);\n    }\n\n    this.next();\n  }\n\n  forward(pos, side) {\n    if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);\n  }\n\n  next() {\n    for (;;) {\n      if (this.chunkIndex == this.layer.chunk.length) {\n        this.from = this.to = 1000000000\n        /* Far */\n        ;\n        this.value = null;\n        break;\n      } else {\n        let chunkPos = this.layer.chunkPos[this.chunkIndex],\n            chunk = this.layer.chunk[this.chunkIndex];\n        let from = chunkPos + chunk.from[this.rangeIndex];\n        this.from = from;\n        this.to = chunkPos + chunk.to[this.rangeIndex];\n        this.value = chunk.value[this.rangeIndex];\n        this.setRangeIndex(this.rangeIndex + 1);\n        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;\n      }\n    }\n  }\n\n  setRangeIndex(index) {\n    if (index == this.layer.chunk[this.chunkIndex].value.length) {\n      this.chunkIndex++;\n\n      if (this.skip) {\n        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex])) this.chunkIndex++;\n      }\n\n      this.rangeIndex = 0;\n    } else {\n      this.rangeIndex = index;\n    }\n  }\n\n  nextChunk() {\n    this.chunkIndex++;\n    this.rangeIndex = 0;\n    this.next();\n  }\n\n  compare(other) {\n    return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;\n  }\n\n}\n\nclass HeapCursor {\n  constructor(heap) {\n    this.heap = heap;\n  }\n\n  static from(sets) {\n    let skip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let minPoint = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n    let heap = [];\n\n    for (let i = 0; i < sets.length; i++) {\n      for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {\n        if (cur.maxPoint >= minPoint) heap.push(new LayerCursor(cur, skip, minPoint, i));\n      }\n    }\n\n    return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n  }\n\n  get startSide() {\n    return this.value ? this.value.startSide : 0;\n  }\n\n  goto(pos) {\n    let side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1000000000;\n\n    for (let cur of this.heap) cur.goto(pos, side);\n\n    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i);\n\n    this.next();\n    return this;\n  }\n\n  forward(pos, side) {\n    for (let cur of this.heap) cur.forward(pos, side);\n\n    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i);\n\n    if ((this.to - pos || this.value.endSide - side) < 0) this.next();\n  }\n\n  next() {\n    if (this.heap.length == 0) {\n      this.from = this.to = 1000000000\n      /* Far */\n      ;\n      this.value = null;\n      this.rank = -1;\n    } else {\n      let top = this.heap[0];\n      this.from = top.from;\n      this.to = top.to;\n      this.value = top.value;\n      this.rank = top.rank;\n      if (top.value) top.next();\n      heapBubble(this.heap, 0);\n    }\n  }\n\n}\n\nfunction heapBubble(heap, index) {\n  for (let cur = heap[index];;) {\n    let childIndex = (index << 1) + 1;\n    if (childIndex >= heap.length) break;\n    let child = heap[childIndex];\n\n    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n      child = heap[childIndex + 1];\n      childIndex++;\n    }\n\n    if (cur.compare(child) < 0) break;\n    heap[childIndex] = cur;\n    heap[index] = child;\n    index = childIndex;\n  }\n}\n\nclass SpanCursor {\n  constructor(sets, skip, minPoint) {\n    let filterPoint = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : () => true;\n    this.minPoint = minPoint;\n    this.filterPoint = filterPoint;\n    this.active = [];\n    this.activeTo = [];\n    this.activeRank = [];\n    this.minActive = -1; // A currently active point range, if any\n\n    this.point = null;\n    this.pointFrom = 0;\n    this.pointRank = 0;\n    this.to = -1000000000\n    /* Far */\n    ;\n    this.endSide = 0;\n    this.openStart = -1;\n    this.cursor = HeapCursor.from(sets, skip, minPoint);\n  }\n\n  goto(pos) {\n    let side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1000000000;\n    this.cursor.goto(pos, side);\n    this.active.length = this.activeTo.length = this.activeRank.length = 0;\n    this.minActive = -1;\n    this.to = pos;\n    this.endSide = side;\n    this.openStart = -1;\n    this.next();\n    return this;\n  }\n\n  forward(pos, side) {\n    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0) this.removeActive(this.minActive);\n\n    this.cursor.forward(pos, side);\n  }\n\n  removeActive(index) {\n    remove(this.active, index);\n    remove(this.activeTo, index);\n    remove(this.activeRank, index);\n    this.minActive = findMinIndex(this.active, this.activeTo);\n  }\n\n  addActive(trackOpen) {\n    let i = 0,\n        {\n      value,\n      to,\n      rank\n    } = this.cursor;\n\n    while (i < this.activeRank.length && this.activeRank[i] <= rank) i++;\n\n    insert(this.active, i, value);\n    insert(this.activeTo, i, to);\n    insert(this.activeRank, i, rank);\n    if (trackOpen) insert(trackOpen, i, this.cursor.from);\n    this.minActive = findMinIndex(this.active, this.activeTo);\n  } // After calling this, if `this.point` != null, the next range is a\n  // point. Otherwise, it's a regular range, covered by `this.active`.\n\n\n  next() {\n    let from = this.to,\n        wasPoint = this.point;\n    this.point = null;\n    let trackOpen = this.openStart < 0 ? [] : null,\n        trackExtra = 0;\n\n    for (;;) {\n      let a = this.minActive;\n\n      if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n        if (this.activeTo[a] > from) {\n          this.to = this.activeTo[a];\n          this.endSide = this.active[a].endSide;\n          break;\n        }\n\n        this.removeActive(a);\n        if (trackOpen) remove(trackOpen, a);\n      } else if (!this.cursor.value) {\n        this.to = this.endSide = 1000000000\n        /* Far */\n        ;\n        break;\n      } else if (this.cursor.from > from) {\n        this.to = this.cursor.from;\n        this.endSide = this.cursor.startSide;\n        break;\n      } else {\n        let nextVal = this.cursor.value;\n\n        if (!nextVal.point) {\n          // Opening a range\n          this.addActive(trackOpen);\n          this.cursor.next();\n        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {\n          // Ignore any non-empty points that end precisely at the end of the prev point\n          this.cursor.next();\n        } else if (!this.filterPoint(this.cursor.from, this.cursor.to, this.cursor.value, this.cursor.rank)) {\n          this.cursor.next();\n        } else {\n          // New point\n          this.point = nextVal;\n          this.pointFrom = this.cursor.from;\n          this.pointRank = this.cursor.rank;\n          this.to = this.cursor.to;\n          this.endSide = nextVal.endSide;\n          if (this.cursor.from < from) trackExtra = 1;\n          this.cursor.next();\n          if (this.to > from) this.forward(this.to, this.endSide);\n          break;\n        }\n      }\n    }\n\n    if (trackOpen) {\n      let openStart = 0;\n\n      while (openStart < trackOpen.length && trackOpen[openStart] < from) openStart++;\n\n      this.openStart = openStart + trackExtra;\n    }\n  }\n\n  activeForPoint(to) {\n    if (!this.active.length) return this.active;\n    let active = [];\n\n    for (let i = this.active.length - 1; i >= 0; i--) {\n      if (this.activeRank[i] < this.pointRank) break;\n      if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide) active.push(this.active[i]);\n    }\n\n    return active.reverse();\n  }\n\n  openEnd(to) {\n    let open = 0;\n\n    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--) open++;\n\n    return open;\n  }\n\n}\n\nfunction compare(a, startA, b, startB, length, comparator) {\n  a.goto(startA);\n  b.goto(startB);\n  let endB = startB + length;\n  let pos = startB,\n      dPos = startB - startA;\n\n  for (;;) {\n    let diff = a.to + dPos - b.to || a.endSide - b.endSide;\n    let end = diff < 0 ? a.to + dPos : b.to,\n        clipEnd = Math.min(end, endB);\n\n    if (a.point || b.point) {\n      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) && sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);\n    } else {\n      if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);\n    }\n\n    if (end > endB) break;\n    pos = end;\n    if (diff <= 0) a.next();\n    if (diff >= 0) b.next();\n  }\n}\n\nfunction sameValues(a, b) {\n  if (a.length != b.length) return false;\n\n  for (let i = 0; i < a.length; i++) if (a[i] != b[i] && !a[i].eq(b[i])) return false;\n\n  return true;\n}\n\nfunction remove(array, index) {\n  for (let i = index, e = array.length - 1; i < e; i++) array[i] = array[i + 1];\n\n  array.pop();\n}\n\nfunction insert(array, index, value) {\n  for (let i = array.length - 1; i >= index; i--) array[i + 1] = array[i];\n\n  array[index] = value;\n}\n\nfunction findMinIndex(value, array) {\n  let found = -1,\n      foundPos = 1000000000\n  /* Far */\n  ;\n\n  for (let i = 0; i < array.length; i++) if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n    found = i;\n    foundPos = array[i];\n  }\n\n  return found;\n}\n\nexport { Range, RangeSet, RangeSetBuilder, RangeValue };","map":{"version":3,"sources":["C:/Users/pc/Desktop/live-code-editor/client/node_modules/@codemirror/rangeset/dist/index.js"],"names":["MapMode","RangeValue","eq","other","range","from","to","Range","prototype","startSide","endSide","point","mapMode","TrackDel","constructor","value","cmpRange","a","b","Chunk","maxPoint","length","findIndex","pos","side","end","startAt","arr","lo","hi","mid","diff","between","offset","f","i","e","map","changes","newPos","val","curFrom","curTo","newFrom","newTo","mapped","mapPos","Math","max","push","RangeSet","chunkPos","chunk","nextLayer","empty","last","chunkEnd","size","isEmpty","index","update","updateSpec","add","sort","filterFrom","filterTo","filter","slice","of","cur","LayerCursor","goto","spill","builder","RangeSetBuilder","addInner","rangeIndex","chunkIndex","addChunk","nextChunk","next","finishInner","chunks","start","touch","touchesRange","iter","HeapCursor","sets","compare","oldSets","newSets","textDiff","comparator","minPointSize","set","sharedChunks","findSharedChunks","sideA","SpanCursor","sideB","iterGaps","fromA","fromB","indexOf","sameValues","active","spans","iterator","_a","cursor","filterPoint","bind","open","openStart","min","activeForPoint","openEnd","span","ranges","build","lazySort","finish","prev","chunkStart","lastFrom","lastTo","setMaxPoint","finishChunk","newArrays","Error","result","inA","Map","shared","Set","known","get","layer","skip","minPoint","rank","gotoInner","forward","has","setRangeIndex","heap","heapBubble","top","childIndex","child","activeTo","activeRank","minActive","pointFrom","pointRank","removeActive","remove","findMinIndex","addActive","trackOpen","insert","wasPoint","trackExtra","nextVal","reverse","startA","startB","endB","dPos","clipEnd","comparePoint","compareRange","array","pop","found","foundPos"],"mappings":"AAAA,SAASA,OAAT,QAAwB,mBAAxB;AAEA;AACA;AACA;AACA;;AACA,MAAMC,UAAN,CAAiB;AACb;AACJ;AACA;AACA;AACIC,EAAAA,EAAE,CAACC,KAAD,EAAQ;AAAE,WAAO,QAAQA,KAAf;AAAuB;AACnC;AACJ;AACA;;;AACIC,EAAAA,KAAK,CAACC,IAAD,EAAkB;AAAA,QAAXC,EAAW,uEAAND,IAAM;AAAE,WAAO,IAAIE,KAAJ,CAAUF,IAAV,EAAgBC,EAAhB,EAAoB,IAApB,CAAP;AAAmC;;AAT/C;;AAWjBL,UAAU,CAACO,SAAX,CAAqBC,SAArB,GAAiCR,UAAU,CAACO,SAAX,CAAqBE,OAArB,GAA+B,CAAhE;AACAT,UAAU,CAACO,SAAX,CAAqBG,KAArB,GAA6B,KAA7B;AACAV,UAAU,CAACO,SAAX,CAAqBI,OAArB,GAA+BZ,OAAO,CAACa,QAAvC;AACA;AACA;AACA;;AACA,MAAMN,KAAN,CAAY;AACR;AACJ;AACA;AACIO,EAAAA,WAAW;AACX;AACJ;AACA;AACIT,EAAAA,IAJW;AAKX;AACJ;AACA;AACIC,EAAAA,EARW;AASX;AACJ;AACA;AACIS,EAAAA,KAZW,EAYJ;AACH,SAAKV,IAAL,GAAYA,IAAZ;AACA,SAAKC,EAAL,GAAUA,EAAV;AACA,SAAKS,KAAL,GAAaA,KAAb;AACH;;AApBO;;AAsBZ,SAASC,QAAT,CAAkBC,CAAlB,EAAqBC,CAArB,EAAwB;AACpB,SAAOD,CAAC,CAACZ,IAAF,GAASa,CAAC,CAACb,IAAX,IAAmBY,CAAC,CAACF,KAAF,CAAQN,SAAR,GAAoBS,CAAC,CAACH,KAAF,CAAQN,SAAtD;AACH;;AACD,MAAMU,KAAN,CAAY;AACRL,EAAAA,WAAW,CAACT,IAAD,EAAOC,EAAP,EAAWS,KAAX,EACX;AACA;AACA;AACA;AACAK,EAAAA,QALW,EAKD;AACN,SAAKf,IAAL,GAAYA,IAAZ;AACA,SAAKC,EAAL,GAAUA,EAAV;AACA,SAAKS,KAAL,GAAaA,KAAb;AACA,SAAKK,QAAL,GAAgBA,QAAhB;AACH;;AACS,MAANC,MAAM,GAAG;AAAE,WAAO,KAAKf,EAAL,CAAQ,KAAKA,EAAL,CAAQe,MAAR,GAAiB,CAAzB,CAAP;AAAqC,GAZ5C,CAaR;AACA;;;AACAC,EAAAA,SAAS,CAACC,GAAD,EAAMC,IAAN,EAAYC,GAAZ,EAA8B;AAAA,QAAbC,OAAa,uEAAH,CAAG;AACnC,QAAIC,GAAG,GAAGF,GAAG,GAAG,KAAKnB,EAAR,GAAa,KAAKD,IAA/B;;AACA,SAAK,IAAIuB,EAAE,GAAGF,OAAT,EAAkBG,EAAE,GAAGF,GAAG,CAACN,MAAhC,IAA0C;AACtC,UAAIO,EAAE,IAAIC,EAAV,EACI,OAAOD,EAAP;AACJ,UAAIE,GAAG,GAAIF,EAAE,GAAGC,EAAN,IAAa,CAAvB;AACA,UAAIE,IAAI,GAAGJ,GAAG,CAACG,GAAD,CAAH,GAAWP,GAAX,IAAkB,CAACE,GAAG,GAAG,KAAKV,KAAL,CAAWe,GAAX,EAAgBpB,OAAnB,GAA6B,KAAKK,KAAL,CAAWe,GAAX,EAAgBrB,SAAjD,IAA8De,IAA3F;AACA,UAAIM,GAAG,IAAIF,EAAX,EACI,OAAOG,IAAI,IAAI,CAAR,GAAYH,EAAZ,GAAiBC,EAAxB;AACJ,UAAIE,IAAI,IAAI,CAAZ,EACIF,EAAE,GAAGC,GAAL,CADJ,KAGIF,EAAE,GAAGE,GAAG,GAAG,CAAX;AACP;AACJ;;AACDE,EAAAA,OAAO,CAACC,MAAD,EAAS5B,IAAT,EAAeC,EAAf,EAAmB4B,CAAnB,EAAsB;AACzB,SAAK,IAAIC,CAAC,GAAG,KAAKb,SAAL,CAAejB,IAAf,EAAqB,CAAC;AAAW;AAAjC,MAA4C,IAA5C,CAAR,EAA2D+B,CAAC,GAAG,KAAKd,SAAL,CAAehB,EAAf,EAAmB;AAAW;AAA9B,MAAyC,KAAzC,EAAgD6B,CAAhD,CAApE,EAAwHA,CAAC,GAAGC,CAA5H,EAA+HD,CAAC,EAAhI,EACI,IAAID,CAAC,CAAC,KAAK7B,IAAL,CAAU8B,CAAV,IAAeF,MAAhB,EAAwB,KAAK3B,EAAL,CAAQ6B,CAAR,IAAaF,MAArC,EAA6C,KAAKlB,KAAL,CAAWoB,CAAX,CAA7C,CAAD,KAAiE,KAArE,EACI,OAAO,KAAP;AACX;;AACDE,EAAAA,GAAG,CAACJ,MAAD,EAASK,OAAT,EAAkB;AACjB,QAAIvB,KAAK,GAAG,EAAZ;AAAA,QAAgBV,IAAI,GAAG,EAAvB;AAAA,QAA2BC,EAAE,GAAG,EAAhC;AAAA,QAAoCiC,MAAM,GAAG,CAAC,CAA9C;AAAA,QAAiDnB,QAAQ,GAAG,CAAC,CAA7D;;AACA,SAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKpB,KAAL,CAAWM,MAA/B,EAAuCc,CAAC,EAAxC,EAA4C;AACxC,UAAIK,GAAG,GAAG,KAAKzB,KAAL,CAAWoB,CAAX,CAAV;AAAA,UAAyBM,OAAO,GAAG,KAAKpC,IAAL,CAAU8B,CAAV,IAAeF,MAAlD;AAAA,UAA0DS,KAAK,GAAG,KAAKpC,EAAL,CAAQ6B,CAAR,IAAaF,MAA/E;AAAA,UAAuFU,OAAvF;AAAA,UAAgGC,KAAhG;;AACA,UAAIH,OAAO,IAAIC,KAAf,EAAsB;AAClB,YAAIG,MAAM,GAAGP,OAAO,CAACQ,MAAR,CAAeL,OAAf,EAAwBD,GAAG,CAAC/B,SAA5B,EAAuC+B,GAAG,CAAC5B,OAA3C,CAAb;AACA,YAAIiC,MAAM,IAAI,IAAd,EACI;AACJF,QAAAA,OAAO,GAAGC,KAAK,GAAGC,MAAlB;;AACA,YAAIL,GAAG,CAAC/B,SAAJ,IAAiB+B,GAAG,CAAC9B,OAAzB,EAAkC;AAC9BkC,UAAAA,KAAK,GAAGN,OAAO,CAACQ,MAAR,CAAeL,OAAf,EAAwBD,GAAG,CAAC9B,OAA5B,CAAR;AACA,cAAIkC,KAAK,GAAGD,OAAZ,EACI;AACP;AACJ,OAVD,MAWK;AACDA,QAAAA,OAAO,GAAGL,OAAO,CAACQ,MAAR,CAAeL,OAAf,EAAwBD,GAAG,CAAC/B,SAA5B,CAAV;AACAmC,QAAAA,KAAK,GAAGN,OAAO,CAACQ,MAAR,CAAeJ,KAAf,EAAsBF,GAAG,CAAC9B,OAA1B,CAAR;AACA,YAAIiC,OAAO,GAAGC,KAAV,IAAmBD,OAAO,IAAIC,KAAX,IAAoBJ,GAAG,CAAC/B,SAAJ,GAAgB,CAApC,IAAyC+B,GAAG,CAAC9B,OAAJ,IAAe,CAA/E,EACI;AACP;;AACD,UAAI,CAACkC,KAAK,GAAGD,OAAR,IAAmBH,GAAG,CAAC9B,OAAJ,GAAc8B,GAAG,CAAC/B,SAAtC,IAAmD,CAAvD,EACI;AACJ,UAAI8B,MAAM,GAAG,CAAb,EACIA,MAAM,GAAGI,OAAT;AACJ,UAAIH,GAAG,CAAC7B,KAAR,EACIS,QAAQ,GAAG2B,IAAI,CAACC,GAAL,CAAS5B,QAAT,EAAmBwB,KAAK,GAAGD,OAA3B,CAAX;AACJ5B,MAAAA,KAAK,CAACkC,IAAN,CAAWT,GAAX;AACAnC,MAAAA,IAAI,CAAC4C,IAAL,CAAUN,OAAO,GAAGJ,MAApB;AACAjC,MAAAA,EAAE,CAAC2C,IAAH,CAAQL,KAAK,GAAGL,MAAhB;AACH;;AACD,WAAO;AAAEM,MAAAA,MAAM,EAAE9B,KAAK,CAACM,MAAN,GAAe,IAAIF,KAAJ,CAAUd,IAAV,EAAgBC,EAAhB,EAAoBS,KAApB,EAA2BK,QAA3B,CAAf,GAAsD,IAAhE;AAAsEG,MAAAA,GAAG,EAAEgB;AAA3E,KAAP;AACH;;AAnEO;AAqEZ;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMW,QAAN,CAAe;AACX;AACJ;AACA;AACIpC,EAAAA,WAAW;AACX;AACJ;AACA;AACIqC,EAAAA,QAJW;AAKX;AACJ;AACA;AACIC,EAAAA,KARW,EAgBD;AAAA,QAJVC,SAIU,uEAJEH,QAAQ,CAACI,KAIX;AAAA;AAHV;AACJ;AACA;AACIlC,IAAAA,QAAU;AACN,SAAK+B,QAAL,GAAgBA,QAAhB;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKjC,QAAL,GAAgBA,QAAhB;AACH;AACD;AACJ;AACA;;;AACc,MAANC,MAAM,GAAG;AACT,QAAIkC,IAAI,GAAG,KAAKH,KAAL,CAAW/B,MAAX,GAAoB,CAA/B;AACA,WAAOkC,IAAI,GAAG,CAAP,GAAW,CAAX,GAAeR,IAAI,CAACC,GAAL,CAAS,KAAKQ,QAAL,CAAcD,IAAd,CAAT,EAA8B,KAAKF,SAAL,CAAehC,MAA7C,CAAtB;AACH;AACD;AACJ;AACA;;;AACY,MAAJoC,IAAI,GAAG;AACP,QAAI,KAAKC,OAAT,EACI,OAAO,CAAP;AACJ,QAAID,IAAI,GAAG,KAAKJ,SAAL,CAAeI,IAA1B;;AACA,SAAK,IAAIL,KAAT,IAAkB,KAAKA,KAAvB,EACIK,IAAI,IAAIL,KAAK,CAACrC,KAAN,CAAYM,MAApB;;AACJ,WAAOoC,IAAP;AACH;AACD;AACJ;AACA;;;AACID,EAAAA,QAAQ,CAACG,KAAD,EAAQ;AACZ,WAAO,KAAKR,QAAL,CAAcQ,KAAd,IAAuB,KAAKP,KAAL,CAAWO,KAAX,EAAkBtC,MAAhD;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACIuC,EAAAA,MAAM,CAACC,UAAD,EAAa;AACf,QAAI;AAAEC,MAAAA,GAAG,GAAG,EAAR;AAAYC,MAAAA,IAAI,GAAG,KAAnB;AAA0BC,MAAAA,UAAU,GAAG,CAAvC;AAA0CC,MAAAA,QAAQ,GAAG,KAAK5C;AAA1D,QAAqEwC,UAAzE;AACA,QAAIK,MAAM,GAAGL,UAAU,CAACK,MAAxB;AACA,QAAIJ,GAAG,CAACzC,MAAJ,IAAc,CAAd,IAAmB,CAAC6C,MAAxB,EACI,OAAO,IAAP;AACJ,QAAIH,IAAJ,EACID,GAAG,CAACK,KAAJ,GAAYJ,IAAZ,CAAiB/C,QAAjB;AACJ,QAAI,KAAK0C,OAAT,EACI,OAAOI,GAAG,CAACzC,MAAJ,GAAa6B,QAAQ,CAACkB,EAAT,CAAYN,GAAZ,CAAb,GAAgC,IAAvC;AACJ,QAAIO,GAAG,GAAG,IAAIC,WAAJ,CAAgB,IAAhB,EAAsB,IAAtB,EAA4B,CAAC,CAA7B,EAAgCC,IAAhC,CAAqC,CAArC,CAAV;AAAA,QAAmDpC,CAAC,GAAG,CAAvD;AAAA,QAA0DqC,KAAK,GAAG,EAAlE;AACA,QAAIC,OAAO,GAAG,IAAIC,eAAJ,EAAd;;AACA,WAAOL,GAAG,CAACtD,KAAJ,IAAaoB,CAAC,GAAG2B,GAAG,CAACzC,MAA5B,EAAoC;AAChC,UAAIc,CAAC,GAAG2B,GAAG,CAACzC,MAAR,IAAkB,CAACgD,GAAG,CAAChE,IAAJ,GAAWyD,GAAG,CAAC3B,CAAD,CAAH,CAAO9B,IAAlB,IAA0BgE,GAAG,CAAC5D,SAAJ,GAAgBqD,GAAG,CAAC3B,CAAD,CAAH,CAAOpB,KAAP,CAAaN,SAAxD,KAAsE,CAA5F,EAA+F;AAC3F,YAAIL,KAAK,GAAG0D,GAAG,CAAC3B,CAAC,EAAF,CAAf;AACA,YAAI,CAACsC,OAAO,CAACE,QAAR,CAAiBvE,KAAK,CAACC,IAAvB,EAA6BD,KAAK,CAACE,EAAnC,EAAuCF,KAAK,CAACW,KAA7C,CAAL,EACIyD,KAAK,CAACvB,IAAN,CAAW7C,KAAX;AACP,OAJD,MAKK,IAAIiE,GAAG,CAACO,UAAJ,IAAkB,CAAlB,IAAuBP,GAAG,CAACQ,UAAJ,GAAiB,KAAKzB,KAAL,CAAW/B,MAAnD,KACJc,CAAC,IAAI2B,GAAG,CAACzC,MAAT,IAAmB,KAAKmC,QAAL,CAAca,GAAG,CAACQ,UAAlB,IAAgCf,GAAG,CAAC3B,CAAD,CAAH,CAAO9B,IADtD,MAEJ,CAAC6D,MAAD,IAAWF,UAAU,GAAG,KAAKR,QAAL,CAAca,GAAG,CAACQ,UAAlB,CAAxB,IAAyDZ,QAAQ,GAAG,KAAKd,QAAL,CAAckB,GAAG,CAACQ,UAAlB,CAFhE,KAGLJ,OAAO,CAACK,QAAR,CAAiB,KAAK3B,QAAL,CAAckB,GAAG,CAACQ,UAAlB,CAAjB,EAAgD,KAAKzB,KAAL,CAAWiB,GAAG,CAACQ,UAAf,CAAhD,CAHC,EAG4E;AAC7ER,QAAAA,GAAG,CAACU,SAAJ;AACH,OALI,MAMA;AACD,YAAI,CAACb,MAAD,IAAWF,UAAU,GAAGK,GAAG,CAAC/D,EAA5B,IAAkC2D,QAAQ,GAAGI,GAAG,CAAChE,IAAjD,IAAyD6D,MAAM,CAACG,GAAG,CAAChE,IAAL,EAAWgE,GAAG,CAAC/D,EAAf,EAAmB+D,GAAG,CAACtD,KAAvB,CAAnE,EAAkG;AAC9F,cAAI,CAAC0D,OAAO,CAACE,QAAR,CAAiBN,GAAG,CAAChE,IAArB,EAA2BgE,GAAG,CAAC/D,EAA/B,EAAmC+D,GAAG,CAACtD,KAAvC,CAAL,EACIyD,KAAK,CAACvB,IAAN,CAAW,IAAI1C,KAAJ,CAAU8D,GAAG,CAAChE,IAAd,EAAoBgE,GAAG,CAAC/D,EAAxB,EAA4B+D,GAAG,CAACtD,KAAhC,CAAX;AACP;;AACDsD,QAAAA,GAAG,CAACW,IAAJ;AACH;AACJ;;AACD,WAAOP,OAAO,CAACQ,WAAR,CAAoB,KAAK5B,SAAL,CAAeK,OAAf,IAA0B,CAACc,KAAK,CAACnD,MAAjC,GAA0C6B,QAAQ,CAACI,KAAnD,GACrB,KAAKD,SAAL,CAAeO,MAAf,CAAsB;AAAEE,MAAAA,GAAG,EAAEU,KAAP;AAAcN,MAAAA,MAAd;AAAsBF,MAAAA,UAAtB;AAAkCC,MAAAA;AAAlC,KAAtB,CADC,CAAP;AAEH;AACD;AACJ;AACA;;;AACI5B,EAAAA,GAAG,CAACC,OAAD,EAAU;AACT,QAAIA,OAAO,CAACjB,MAAR,IAAkB,CAAlB,IAAuB,KAAKqC,OAAhC,EACI,OAAO,IAAP;AACJ,QAAIwB,MAAM,GAAG,EAAb;AAAA,QAAiB/B,QAAQ,GAAG,EAA5B;AAAA,QAAgC/B,QAAQ,GAAG,CAAC,CAA5C;;AACA,SAAK,IAAIe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKiB,KAAL,CAAW/B,MAA/B,EAAuCc,CAAC,EAAxC,EAA4C;AACxC,UAAIgD,KAAK,GAAG,KAAKhC,QAAL,CAAchB,CAAd,CAAZ;AAAA,UAA8BiB,KAAK,GAAG,KAAKA,KAAL,CAAWjB,CAAX,CAAtC;AACA,UAAIiD,KAAK,GAAG9C,OAAO,CAAC+C,YAAR,CAAqBF,KAArB,EAA4BA,KAAK,GAAG/B,KAAK,CAAC/B,MAA1C,CAAZ;;AACA,UAAI+D,KAAK,KAAK,KAAd,EAAqB;AACjBhE,QAAAA,QAAQ,GAAG2B,IAAI,CAACC,GAAL,CAAS5B,QAAT,EAAmBgC,KAAK,CAAChC,QAAzB,CAAX;AACA8D,QAAAA,MAAM,CAACjC,IAAP,CAAYG,KAAZ;AACAD,QAAAA,QAAQ,CAACF,IAAT,CAAcX,OAAO,CAACQ,MAAR,CAAeqC,KAAf,CAAd;AACH,OAJD,MAKK,IAAIC,KAAK,KAAK,IAAd,EAAoB;AACrB,YAAI;AAAEvC,UAAAA,MAAF;AAAUtB,UAAAA;AAAV,YAAkB6B,KAAK,CAACf,GAAN,CAAU8C,KAAV,EAAiB7C,OAAjB,CAAtB;;AACA,YAAIO,MAAJ,EAAY;AACRzB,UAAAA,QAAQ,GAAG2B,IAAI,CAACC,GAAL,CAAS5B,QAAT,EAAmByB,MAAM,CAACzB,QAA1B,CAAX;AACA8D,UAAAA,MAAM,CAACjC,IAAP,CAAYJ,MAAZ;AACAM,UAAAA,QAAQ,CAACF,IAAT,CAAc1B,GAAd;AACH;AACJ;AACJ;;AACD,QAAIyD,IAAI,GAAG,KAAK3B,SAAL,CAAehB,GAAf,CAAmBC,OAAnB,CAAX;AACA,WAAO4C,MAAM,CAAC7D,MAAP,IAAiB,CAAjB,GAAqB2D,IAArB,GAA4B,IAAI9B,QAAJ,CAAaC,QAAb,EAAuB+B,MAAvB,EAA+BF,IAA/B,EAAqC5D,QAArC,CAAnC;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;AACIY,EAAAA,OAAO,CAAC3B,IAAD,EAAOC,EAAP,EAAW4B,CAAX,EAAc;AACjB,QAAI,KAAKwB,OAAT,EACI;;AACJ,SAAK,IAAIvB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKiB,KAAL,CAAW/B,MAA/B,EAAuCc,CAAC,EAAxC,EAA4C;AACxC,UAAIgD,KAAK,GAAG,KAAKhC,QAAL,CAAchB,CAAd,CAAZ;AAAA,UAA8BiB,KAAK,GAAG,KAAKA,KAAL,CAAWjB,CAAX,CAAtC;AACA,UAAI7B,EAAE,IAAI6E,KAAN,IAAe9E,IAAI,IAAI8E,KAAK,GAAG/B,KAAK,CAAC/B,MAArC,IACA+B,KAAK,CAACpB,OAAN,CAAcmD,KAAd,EAAqB9E,IAAI,GAAG8E,KAA5B,EAAmC7E,EAAE,GAAG6E,KAAxC,EAA+CjD,CAA/C,MAAsD,KAD1D,EAEI;AACP;;AACD,SAAKmB,SAAL,CAAerB,OAAf,CAAuB3B,IAAvB,EAA6BC,EAA7B,EAAiC4B,CAAjC;AACH;AACD;AACJ;AACA;AACA;;;AACIoD,EAAAA,IAAI,GAAW;AAAA,QAAVjF,IAAU,uEAAH,CAAG;AACX,WAAOkF,UAAU,CAAClF,IAAX,CAAgB,CAAC,IAAD,CAAhB,EAAwBkE,IAAxB,CAA6BlE,IAA7B,CAAP;AACH;AACD;AACJ;AACA;;;AACe,MAAPqD,OAAO,GAAG;AAAE,WAAO,KAAKL,SAAL,IAAkB,IAAzB;AAAgC;AAChD;AACJ;AACA;AACA;;;AACe,SAAJiC,IAAI,CAACE,IAAD,EAAiB;AAAA,QAAVnF,IAAU,uEAAH,CAAG;AACxB,WAAOkF,UAAU,CAAClF,IAAX,CAAgBmF,IAAhB,EAAsBjB,IAAtB,CAA2BlE,IAA3B,CAAP;AACH;AACD;AACJ;AACA;AACA;;;AACkB,SAAPoF,OAAO,CAACC,OAAD,EAAUC,OAAV;AACd;AACJ;AACA;AACA;AACA;AACIC,EAAAA,QANc,EAMJC,UANI,EAWK;AAAA,QAAnBC,YAAmB,uEAAJ,CAAC,CAAG;AACf,QAAI7E,CAAC,GAAGyE,OAAO,CAACxB,MAAR,CAAe6B,GAAG,IAAIA,GAAG,CAAC3E,QAAJ,GAAe,CAAf,IAAoB,CAAC2E,GAAG,CAACrC,OAAL,IAAgBqC,GAAG,CAAC3E,QAAJ,IAAgB0E,YAA1E,CAAR;AACA,QAAI5E,CAAC,GAAGyE,OAAO,CAACzB,MAAR,CAAe6B,GAAG,IAAIA,GAAG,CAAC3E,QAAJ,GAAe,CAAf,IAAoB,CAAC2E,GAAG,CAACrC,OAAL,IAAgBqC,GAAG,CAAC3E,QAAJ,IAAgB0E,YAA1E,CAAR;AACA,QAAIE,YAAY,GAAGC,gBAAgB,CAAChF,CAAD,EAAIC,CAAJ,EAAO0E,QAAP,CAAnC;AACA,QAAIM,KAAK,GAAG,IAAIC,UAAJ,CAAelF,CAAf,EAAkB+E,YAAlB,EAAgCF,YAAhC,CAAZ;AACA,QAAIM,KAAK,GAAG,IAAID,UAAJ,CAAejF,CAAf,EAAkB8E,YAAlB,EAAgCF,YAAhC,CAAZ;AACAF,IAAAA,QAAQ,CAACS,QAAT,CAAkB,CAACC,KAAD,EAAQC,KAAR,EAAelF,MAAf,KAA0BoE,OAAO,CAACS,KAAD,EAAQI,KAAR,EAAeF,KAAf,EAAsBG,KAAtB,EAA6BlF,MAA7B,EAAqCwE,UAArC,CAAnD;AACA,QAAID,QAAQ,CAACtC,KAAT,IAAkBsC,QAAQ,CAACvE,MAAT,IAAmB,CAAzC,EACIoE,OAAO,CAACS,KAAD,EAAQ,CAAR,EAAWE,KAAX,EAAkB,CAAlB,EAAqB,CAArB,EAAwBP,UAAxB,CAAP;AACP;AACD;AACJ;AACA;AACA;;;AACa,SAAF3F,EAAE,CAACwF,OAAD,EAAUC,OAAV,EAAiC;AAAA,QAAdtF,IAAc,uEAAP,CAAO;AAAA,QAAJC,EAAI;AACtC,QAAIA,EAAE,IAAI,IAAV,EACIA,EAAE,GAAG;AAAW;AAAhB;AACJ,QAAIW,CAAC,GAAGyE,OAAO,CAACxB,MAAR,CAAe6B,GAAG,IAAI,CAACA,GAAG,CAACrC,OAAL,IAAgBiC,OAAO,CAACa,OAAR,CAAgBT,GAAhB,IAAuB,CAA7D,CAAR;AACA,QAAI7E,CAAC,GAAGyE,OAAO,CAACzB,MAAR,CAAe6B,GAAG,IAAI,CAACA,GAAG,CAACrC,OAAL,IAAgBgC,OAAO,CAACc,OAAR,CAAgBT,GAAhB,IAAuB,CAA7D,CAAR;AACA,QAAI9E,CAAC,CAACI,MAAF,IAAYH,CAAC,CAACG,MAAlB,EACI,OAAO,KAAP;AACJ,QAAI,CAACJ,CAAC,CAACI,MAAP,EACI,OAAO,IAAP;AACJ,QAAI2E,YAAY,GAAGC,gBAAgB,CAAChF,CAAD,EAAIC,CAAJ,CAAnC;AACA,QAAIgF,KAAK,GAAG,IAAIC,UAAJ,CAAelF,CAAf,EAAkB+E,YAAlB,EAAgC,CAAhC,EAAmCzB,IAAnC,CAAwClE,IAAxC,CAAZ;AAAA,QAA2D+F,KAAK,GAAG,IAAID,UAAJ,CAAejF,CAAf,EAAkB8E,YAAlB,EAAgC,CAAhC,EAAmCzB,IAAnC,CAAwClE,IAAxC,CAAnE;;AACA,aAAS;AACL,UAAI6F,KAAK,CAAC5F,EAAN,IAAY8F,KAAK,CAAC9F,EAAlB,IACA,CAACmG,UAAU,CAACP,KAAK,CAACQ,MAAP,EAAeN,KAAK,CAACM,MAArB,CADX,IAEAR,KAAK,CAACvF,KAAN,KAAgB,CAACyF,KAAK,CAACzF,KAAP,IAAgB,CAACuF,KAAK,CAACvF,KAAN,CAAYT,EAAZ,CAAekG,KAAK,CAACzF,KAArB,CAAjC,CAFJ,EAGI,OAAO,KAAP;AACJ,UAAIuF,KAAK,CAAC5F,EAAN,GAAWA,EAAf,EACI,OAAO,IAAP;AACJ4F,MAAAA,KAAK,CAAClB,IAAN;AACAoB,MAAAA,KAAK,CAACpB,IAAN;AACH;AACJ;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACgB,SAAL2B,KAAK,CAACnB,IAAD,EAAOnF,IAAP,EAAaC,EAAb,EAAiBsG,QAAjB,EAKO;AAAA,QAAnBd,YAAmB,uEAAJ,CAAC,CAAG;;AACf,QAAIe,EAAJ;;AACA,QAAIC,MAAM,GAAG,IAAIX,UAAJ,CAAeX,IAAf,EAAqB,IAArB,EAA2BM,YAA3B,EAAyC,CAACe,EAAE,GAAGD,QAAQ,CAACG,WAAf,MAAgC,IAAhC,IAAwCF,EAAE,KAAK,KAAK,CAApD,GAAwD,KAAK,CAA7D,GAAiEA,EAAE,CAACG,IAAH,CAAQJ,QAAR,CAA1G,EAA6HrC,IAA7H,CAAkIlE,IAAlI,CAAb;AAAA,QAAsJkB,GAAG,GAAGlB,IAA5J;AACA,QAAI4G,IAAI,GAAGH,MAAM,CAACI,SAAlB;;AACA,aAAS;AACL,UAAIxE,KAAK,GAAGK,IAAI,CAACoE,GAAL,CAASL,MAAM,CAACxG,EAAhB,EAAoBA,EAApB,CAAZ;;AACA,UAAIwG,MAAM,CAACnG,KAAX,EAAkB;AACdiG,QAAAA,QAAQ,CAACjG,KAAT,CAAeY,GAAf,EAAoBmB,KAApB,EAA2BoE,MAAM,CAACnG,KAAlC,EAAyCmG,MAAM,CAACM,cAAP,CAAsBN,MAAM,CAACxG,EAA7B,CAAzC,EAA2E2G,IAA3E;AACAA,QAAAA,IAAI,GAAGH,MAAM,CAACO,OAAP,CAAe3E,KAAf,KAAyBoE,MAAM,CAACxG,EAAP,GAAYoC,KAAZ,GAAoB,CAApB,GAAwB,CAAjD,CAAP;AACH,OAHD,MAIK,IAAIA,KAAK,GAAGnB,GAAZ,EAAiB;AAClBqF,QAAAA,QAAQ,CAACU,IAAT,CAAc/F,GAAd,EAAmBmB,KAAnB,EAA0BoE,MAAM,CAACJ,MAAjC,EAAyCO,IAAzC;AACAA,QAAAA,IAAI,GAAGH,MAAM,CAACO,OAAP,CAAe3E,KAAf,CAAP;AACH;;AACD,UAAIoE,MAAM,CAACxG,EAAP,GAAYA,EAAhB,EACI;AACJiB,MAAAA,GAAG,GAAGuF,MAAM,CAACxG,EAAb;AACAwG,MAAAA,MAAM,CAAC9B,IAAP;AACH;;AACD,WAAOiC,IAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACa,SAAF7C,EAAE,CAACmD,MAAD,EAAuB;AAAA,QAAdxD,IAAc,uEAAP,KAAO;AAC5B,QAAIyD,KAAK,GAAG,IAAI9C,eAAJ,EAAZ;;AACA,SAAK,IAAItE,KAAT,IAAkBmH,MAAM,YAAYhH,KAAlB,GAA0B,CAACgH,MAAD,CAA1B,GAAqCxD,IAAI,GAAG0D,QAAQ,CAACF,MAAD,CAAX,GAAsBA,MAAjF,EACIC,KAAK,CAAC1D,GAAN,CAAU1D,KAAK,CAACC,IAAhB,EAAsBD,KAAK,CAACE,EAA5B,EAAgCF,KAAK,CAACW,KAAtC;;AACJ,WAAOyG,KAAK,CAACE,MAAN,EAAP;AACH;;AA3PU;AA6Pf;AACA;AACA;;;AACAxE,QAAQ,CAACI,KAAT,GAAiB,aAAa,IAAIJ,QAAJ,CAAa,EAAb,EAAiB,EAAjB,EAAqB,IAArB,EAA2B,CAAC,CAA5B,CAA9B;;AACA,SAASuE,QAAT,CAAkBF,MAAlB,EAA0B;AACtB,MAAIA,MAAM,CAAClG,MAAP,GAAgB,CAApB,EACI,KAAK,IAAIsG,IAAI,GAAGJ,MAAM,CAAC,CAAD,CAAjB,EAAsBpF,CAAC,GAAG,CAA/B,EAAkCA,CAAC,GAAGoF,MAAM,CAAClG,MAA7C,EAAqDc,CAAC,EAAtD,EAA0D;AACtD,QAAIkC,GAAG,GAAGkD,MAAM,CAACpF,CAAD,CAAhB;AACA,QAAInB,QAAQ,CAAC2G,IAAD,EAAOtD,GAAP,CAAR,GAAsB,CAA1B,EACI,OAAOkD,MAAM,CAACpD,KAAP,GAAeJ,IAAf,CAAoB/C,QAApB,CAAP;AACJ2G,IAAAA,IAAI,GAAGtD,GAAP;AACH;AACL,SAAOkD,MAAP;AACH;;AACDrE,QAAQ,CAACI,KAAT,CAAeD,SAAf,GAA2BH,QAAQ,CAACI,KAApC;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMoB,eAAN,CAAsB;AAClB;AACJ;AACA;AACI5D,EAAAA,WAAW,GAAG;AACV,SAAKoE,MAAL,GAAc,EAAd;AACA,SAAK/B,QAAL,GAAgB,EAAhB;AACA,SAAKyE,UAAL,GAAkB,CAAC,CAAnB;AACA,SAAKrE,IAAL,GAAY,IAAZ;AACA,SAAKsE,QAAL,GAAgB,CAAC;AAAW;AAA5B;AACA,SAAKC,MAAL,GAAc,CAAC;AAAW;AAA1B;AACA,SAAKzH,IAAL,GAAY,EAAZ;AACA,SAAKC,EAAL,GAAU,EAAV;AACA,SAAKS,KAAL,GAAa,EAAb;AACA,SAAKK,QAAL,GAAgB,CAAC,CAAjB;AACA,SAAK2G,WAAL,GAAmB,CAAC,CAApB;AACA,SAAK1E,SAAL,GAAiB,IAAjB;AACH;;AACD2E,EAAAA,WAAW,CAACC,SAAD,EAAY;AACnB,SAAK/C,MAAL,CAAYjC,IAAZ,CAAiB,IAAI9B,KAAJ,CAAU,KAAKd,IAAf,EAAqB,KAAKC,EAA1B,EAA8B,KAAKS,KAAnC,EAA0C,KAAKK,QAA/C,CAAjB;AACA,SAAK+B,QAAL,CAAcF,IAAd,CAAmB,KAAK2E,UAAxB;AACA,SAAKA,UAAL,GAAkB,CAAC,CAAnB;AACA,SAAKG,WAAL,GAAmBhF,IAAI,CAACC,GAAL,CAAS,KAAK+E,WAAd,EAA2B,KAAK3G,QAAhC,CAAnB;AACA,SAAKA,QAAL,GAAgB,CAAC,CAAjB;;AACA,QAAI6G,SAAJ,EAAe;AACX,WAAK5H,IAAL,GAAY,EAAZ;AACA,WAAKC,EAAL,GAAU,EAAV;AACA,WAAKS,KAAL,GAAa,EAAb;AACH;AACJ;AACD;AACJ;AACA;AACA;;;AACI+C,EAAAA,GAAG,CAACzD,IAAD,EAAOC,EAAP,EAAWS,KAAX,EAAkB;AACjB,QAAI,CAAC,KAAK4D,QAAL,CAActE,IAAd,EAAoBC,EAApB,EAAwBS,KAAxB,CAAL,EACI,CAAC,KAAKsC,SAAL,KAAmB,KAAKA,SAAL,GAAiB,IAAIqB,eAAJ,EAApC,CAAD,EAA2DZ,GAA3D,CAA+DzD,IAA/D,EAAqEC,EAArE,EAAyES,KAAzE;AACP;AACD;AACJ;AACA;;;AACI4D,EAAAA,QAAQ,CAACtE,IAAD,EAAOC,EAAP,EAAWS,KAAX,EAAkB;AACtB,QAAIgB,IAAI,GAAG1B,IAAI,GAAG,KAAKyH,MAAZ,IAAsB/G,KAAK,CAACN,SAAN,GAAkB,KAAK8C,IAAL,CAAU7C,OAA7D;AACA,QAAIqB,IAAI,IAAI,CAAR,IAAa,CAAC1B,IAAI,GAAG,KAAKwH,QAAZ,IAAwB9G,KAAK,CAACN,SAAN,GAAkB,KAAK8C,IAAL,CAAU9C,SAArD,IAAkE,CAAnF,EACI,MAAM,IAAIyH,KAAJ,CAAU,gEAAV,CAAN;AACJ,QAAInG,IAAI,GAAG,CAAX,EACI,OAAO,KAAP;AACJ,QAAI,KAAK1B,IAAL,CAAUgB,MAAV,IAAoB;AAAI;AAA5B,MACI,KAAK2G,WAAL,CAAiB,IAAjB;AACJ,QAAI,KAAKJ,UAAL,GAAkB,CAAtB,EACI,KAAKA,UAAL,GAAkBvH,IAAlB;AACJ,SAAKA,IAAL,CAAU4C,IAAV,CAAe5C,IAAI,GAAG,KAAKuH,UAA3B;AACA,SAAKtH,EAAL,CAAQ2C,IAAR,CAAa3C,EAAE,GAAG,KAAKsH,UAAvB;AACA,SAAKrE,IAAL,GAAYxC,KAAZ;AACA,SAAK8G,QAAL,GAAgBxH,IAAhB;AACA,SAAKyH,MAAL,GAAcxH,EAAd;AACA,SAAKS,KAAL,CAAWkC,IAAX,CAAgBlC,KAAhB;AACA,QAAIA,KAAK,CAACJ,KAAV,EACI,KAAKS,QAAL,GAAgB2B,IAAI,CAACC,GAAL,CAAS,KAAK5B,QAAd,EAAwBd,EAAE,GAAGD,IAA7B,CAAhB;AACJ,WAAO,IAAP;AACH;AACD;AACJ;AACA;;;AACIyE,EAAAA,QAAQ,CAACzE,IAAD,EAAO+C,KAAP,EAAc;AAClB,QAAI,CAAC/C,IAAI,GAAG,KAAKyH,MAAZ,IAAsB1E,KAAK,CAACrC,KAAN,CAAY,CAAZ,EAAeN,SAAf,GAA2B,KAAK8C,IAAL,CAAU7C,OAA5D,IAAuE,CAA3E,EACI,OAAO,KAAP;AACJ,QAAI,KAAKL,IAAL,CAAUgB,MAAd,EACI,KAAK2G,WAAL,CAAiB,IAAjB;AACJ,SAAKD,WAAL,GAAmBhF,IAAI,CAACC,GAAL,CAAS,KAAK+E,WAAd,EAA2B3E,KAAK,CAAChC,QAAjC,CAAnB;AACA,SAAK8D,MAAL,CAAYjC,IAAZ,CAAiBG,KAAjB;AACA,SAAKD,QAAL,CAAcF,IAAd,CAAmB5C,IAAnB;AACA,QAAIkD,IAAI,GAAGH,KAAK,CAACrC,KAAN,CAAYM,MAAZ,GAAqB,CAAhC;AACA,SAAKkC,IAAL,GAAYH,KAAK,CAACrC,KAAN,CAAYwC,IAAZ,CAAZ;AACA,SAAKsE,QAAL,GAAgBzE,KAAK,CAAC/C,IAAN,CAAWkD,IAAX,IAAmBlD,IAAnC;AACA,SAAKyH,MAAL,GAAc1E,KAAK,CAAC9C,EAAN,CAASiD,IAAT,IAAiBlD,IAA/B;AACA,WAAO,IAAP;AACH;AACD;AACJ;AACA;AACA;;;AACIqH,EAAAA,MAAM,GAAG;AAAE,WAAO,KAAKzC,WAAL,CAAiB/B,QAAQ,CAACI,KAA1B,CAAP;AAA0C;AACrD;AACJ;AACA;;;AACI2B,EAAAA,WAAW,CAACD,IAAD,EAAO;AACd,QAAI,KAAK3E,IAAL,CAAUgB,MAAd,EACI,KAAK2G,WAAL,CAAiB,KAAjB;AACJ,QAAI,KAAK9C,MAAL,CAAY7D,MAAZ,IAAsB,CAA1B,EACI,OAAO2D,IAAP;AACJ,QAAImD,MAAM,GAAG,IAAIjF,QAAJ,CAAa,KAAKC,QAAlB,EAA4B,KAAK+B,MAAjC,EAAyC,KAAK7B,SAAL,GAAiB,KAAKA,SAAL,CAAe4B,WAAf,CAA2BD,IAA3B,CAAjB,GAAoDA,IAA7F,EAAmG,KAAK+C,WAAxG,CAAb;AACA,SAAK1H,IAAL,GAAY,IAAZ,CANc,CAMI;;AAClB,WAAO8H,MAAP;AACH;;AA9FiB;;AAgGtB,SAASlC,gBAAT,CAA0BhF,CAA1B,EAA6BC,CAA7B,EAAgC0E,QAAhC,EAA0C;AACtC,MAAIwC,GAAG,GAAG,IAAIC,GAAJ,EAAV;;AACA,OAAK,IAAItC,GAAT,IAAgB9E,CAAhB,EACI,KAAK,IAAIkB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4D,GAAG,CAAC3C,KAAJ,CAAU/B,MAA9B,EAAsCc,CAAC,EAAvC,EACI,IAAI4D,GAAG,CAAC3C,KAAJ,CAAUjB,CAAV,EAAaf,QAAb,IAAyB,CAA7B,EACIgH,GAAG,CAACrC,GAAJ,CAAQA,GAAG,CAAC3C,KAAJ,CAAUjB,CAAV,CAAR,EAAsB4D,GAAG,CAAC5C,QAAJ,CAAahB,CAAb,CAAtB;;AACZ,MAAImG,MAAM,GAAG,IAAIC,GAAJ,EAAb;;AACA,OAAK,IAAIxC,GAAT,IAAgB7E,CAAhB,EACI,KAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG4D,GAAG,CAAC3C,KAAJ,CAAU/B,MAA9B,EAAsCc,CAAC,EAAvC,EAA2C;AACvC,QAAIqG,KAAK,GAAGJ,GAAG,CAACK,GAAJ,CAAQ1C,GAAG,CAAC3C,KAAJ,CAAUjB,CAAV,CAAR,CAAZ;AACA,QAAIqG,KAAK,IAAI,IAAT,IAAiB,CAAC5C,QAAQ,GAAGA,QAAQ,CAAC9C,MAAT,CAAgB0F,KAAhB,CAAH,GAA4BA,KAArC,KAA+CzC,GAAG,CAAC5C,QAAJ,CAAahB,CAAb,CAAhE,IACA,EAAEyD,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAACP,YAAT,CAAsBmD,KAAtB,EAA6BA,KAAK,GAAGzC,GAAG,CAAC3C,KAAJ,CAAUjB,CAAV,EAAad,MAAlD,CAAtD,CADJ,EAEIiH,MAAM,CAACxE,GAAP,CAAWiC,GAAG,CAAC3C,KAAJ,CAAUjB,CAAV,CAAX;AACP;;AACL,SAAOmG,MAAP;AACH;;AACD,MAAMhE,WAAN,CAAkB;AACdxD,EAAAA,WAAW,CAAC4H,KAAD,EAAQC,IAAR,EAAcC,QAAd,EAAkC;AAAA,QAAVC,IAAU,uEAAH,CAAG;AACzC,SAAKH,KAAL,GAAaA,KAAb;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACH;;AACY,MAATpI,SAAS,GAAG;AAAE,WAAO,KAAKM,KAAL,GAAa,KAAKA,KAAL,CAAWN,SAAxB,GAAoC,CAA3C;AAA+C;;AACtD,MAAPC,OAAO,GAAG;AAAE,WAAO,KAAKK,KAAL,GAAa,KAAKA,KAAL,CAAWL,OAAxB,GAAkC,CAAzC;AAA6C;;AAC7D6D,EAAAA,IAAI,CAAChD,GAAD,EAAoC;AAAA,QAA9BC,IAA8B,uEAAvB,CAAC,UAAsB;AACpC,SAAKqD,UAAL,GAAkB,KAAKD,UAAL,GAAkB,CAApC;AACA,SAAKkE,SAAL,CAAevH,GAAf,EAAoBC,IAApB,EAA0B,KAA1B;AACA,WAAO,IAAP;AACH;;AACDsH,EAAAA,SAAS,CAACvH,GAAD,EAAMC,IAAN,EAAYuH,OAAZ,EAAqB;AAC1B,WAAO,KAAKlE,UAAL,GAAkB,KAAK6D,KAAL,CAAWtF,KAAX,CAAiB/B,MAA1C,EAAkD;AAC9C,UAAI2D,IAAI,GAAG,KAAK0D,KAAL,CAAWtF,KAAX,CAAiB,KAAKyB,UAAtB,CAAX;AACA,UAAI,EAAE,KAAK8D,IAAL,IAAa,KAAKA,IAAL,CAAUK,GAAV,CAAchE,IAAd,CAAb,IACF,KAAK0D,KAAL,CAAWlF,QAAX,CAAoB,KAAKqB,UAAzB,IAAuCtD,GADrC,IAEFyD,IAAI,CAAC5D,QAAL,GAAgB,KAAKwH,QAFrB,CAAJ,EAGI;AACJ,WAAK/D,UAAL;AACAkE,MAAAA,OAAO,GAAG,KAAV;AACH;;AACD,QAAI,KAAKlE,UAAL,GAAkB,KAAK6D,KAAL,CAAWtF,KAAX,CAAiB/B,MAAvC,EAA+C;AAC3C,UAAIuD,UAAU,GAAG,KAAK8D,KAAL,CAAWtF,KAAX,CAAiB,KAAKyB,UAAtB,EAAkCvD,SAAlC,CAA4CC,GAAG,GAAG,KAAKmH,KAAL,CAAWvF,QAAX,CAAoB,KAAK0B,UAAzB,CAAlD,EAAwFrD,IAAxF,EAA8F,IAA9F,CAAjB;AACA,UAAI,CAACuH,OAAD,IAAY,KAAKnE,UAAL,GAAkBA,UAAlC,EACI,KAAKqE,aAAL,CAAmBrE,UAAnB;AACP;;AACD,SAAKI,IAAL;AACH;;AACD+D,EAAAA,OAAO,CAACxH,GAAD,EAAMC,IAAN,EAAY;AACf,QAAI,CAAC,KAAKlB,EAAL,GAAUiB,GAAV,IAAiB,KAAKb,OAAL,GAAec,IAAjC,IAAyC,CAA7C,EACI,KAAKsH,SAAL,CAAevH,GAAf,EAAoBC,IAApB,EAA0B,IAA1B;AACP;;AACDwD,EAAAA,IAAI,GAAG;AACH,aAAS;AACL,UAAI,KAAKH,UAAL,IAAmB,KAAK6D,KAAL,CAAWtF,KAAX,CAAiB/B,MAAxC,EAAgD;AAC5C,aAAKhB,IAAL,GAAY,KAAKC,EAAL,GAAU;AAAW;AAAjC;AACA,aAAKS,KAAL,GAAa,IAAb;AACA;AACH,OAJD,MAKK;AACD,YAAIoC,QAAQ,GAAG,KAAKuF,KAAL,CAAWvF,QAAX,CAAoB,KAAK0B,UAAzB,CAAf;AAAA,YAAqDzB,KAAK,GAAG,KAAKsF,KAAL,CAAWtF,KAAX,CAAiB,KAAKyB,UAAtB,CAA7D;AACA,YAAIxE,IAAI,GAAG8C,QAAQ,GAAGC,KAAK,CAAC/C,IAAN,CAAW,KAAKuE,UAAhB,CAAtB;AACA,aAAKvE,IAAL,GAAYA,IAAZ;AACA,aAAKC,EAAL,GAAU6C,QAAQ,GAAGC,KAAK,CAAC9C,EAAN,CAAS,KAAKsE,UAAd,CAArB;AACA,aAAK7D,KAAL,GAAaqC,KAAK,CAACrC,KAAN,CAAY,KAAK6D,UAAjB,CAAb;AACA,aAAKqE,aAAL,CAAmB,KAAKrE,UAAL,GAAkB,CAArC;AACA,YAAI,KAAKgE,QAAL,GAAgB,CAAhB,IAAqB,KAAK7H,KAAL,CAAWJ,KAAX,IAAoB,KAAKL,EAAL,GAAU,KAAKD,IAAf,IAAuB,KAAKuI,QAAzE,EACI;AACP;AACJ;AACJ;;AACDK,EAAAA,aAAa,CAACtF,KAAD,EAAQ;AACjB,QAAIA,KAAK,IAAI,KAAK+E,KAAL,CAAWtF,KAAX,CAAiB,KAAKyB,UAAtB,EAAkC9D,KAAlC,CAAwCM,MAArD,EAA6D;AACzD,WAAKwD,UAAL;;AACA,UAAI,KAAK8D,IAAT,EAAe;AACX,eAAO,KAAK9D,UAAL,GAAkB,KAAK6D,KAAL,CAAWtF,KAAX,CAAiB/B,MAAnC,IAA6C,KAAKsH,IAAL,CAAUK,GAAV,CAAc,KAAKN,KAAL,CAAWtF,KAAX,CAAiB,KAAKyB,UAAtB,CAAd,CAApD,EACI,KAAKA,UAAL;AACP;;AACD,WAAKD,UAAL,GAAkB,CAAlB;AACH,KAPD,MAQK;AACD,WAAKA,UAAL,GAAkBjB,KAAlB;AACH;AACJ;;AACDoB,EAAAA,SAAS,GAAG;AACR,SAAKF,UAAL;AACA,SAAKD,UAAL,GAAkB,CAAlB;AACA,SAAKI,IAAL;AACH;;AACDS,EAAAA,OAAO,CAACtF,KAAD,EAAQ;AACX,WAAO,KAAKE,IAAL,GAAYF,KAAK,CAACE,IAAlB,IAA0B,KAAKI,SAAL,GAAiBN,KAAK,CAACM,SAAjD,IAA8D,KAAKH,EAAL,GAAUH,KAAK,CAACG,EAA9E,IAAoF,KAAKI,OAAL,GAAeP,KAAK,CAACO,OAAhH;AACH;;AA1Ea;;AA4ElB,MAAM6E,UAAN,CAAiB;AACbzE,EAAAA,WAAW,CAACoI,IAAD,EAAO;AACd,SAAKA,IAAL,GAAYA,IAAZ;AACH;;AACU,SAAJ7I,IAAI,CAACmF,IAAD,EAAmC;AAAA,QAA5BmD,IAA4B,uEAArB,IAAqB;AAAA,QAAfC,QAAe,uEAAJ,CAAC,CAAG;AAC1C,QAAIM,IAAI,GAAG,EAAX;;AACA,SAAK,IAAI/G,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqD,IAAI,CAACnE,MAAzB,EAAiCc,CAAC,EAAlC,EAAsC;AAClC,WAAK,IAAIkC,GAAG,GAAGmB,IAAI,CAACrD,CAAD,CAAnB,EAAwB,CAACkC,GAAG,CAACX,OAA7B,EAAsCW,GAAG,GAAGA,GAAG,CAAChB,SAAhD,EAA2D;AACvD,YAAIgB,GAAG,CAACjD,QAAJ,IAAgBwH,QAApB,EACIM,IAAI,CAACjG,IAAL,CAAU,IAAIqB,WAAJ,CAAgBD,GAAhB,EAAqBsE,IAArB,EAA2BC,QAA3B,EAAqCzG,CAArC,CAAV;AACP;AACJ;;AACD,WAAO+G,IAAI,CAAC7H,MAAL,IAAe,CAAf,GAAmB6H,IAAI,CAAC,CAAD,CAAvB,GAA6B,IAAI3D,UAAJ,CAAe2D,IAAf,CAApC;AACH;;AACY,MAATzI,SAAS,GAAG;AAAE,WAAO,KAAKM,KAAL,GAAa,KAAKA,KAAL,CAAWN,SAAxB,GAAoC,CAA3C;AAA+C;;AACjE8D,EAAAA,IAAI,CAAChD,GAAD,EAAoC;AAAA,QAA9BC,IAA8B,uEAAvB,CAAC,UAAsB;;AACpC,SAAK,IAAI6C,GAAT,IAAgB,KAAK6E,IAArB,EACI7E,GAAG,CAACE,IAAJ,CAAShD,GAAT,EAAcC,IAAd;;AACJ,SAAK,IAAIW,CAAC,GAAG,KAAK+G,IAAL,CAAU7H,MAAV,IAAoB,CAAjC,EAAoCc,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EACIgH,UAAU,CAAC,KAAKD,IAAN,EAAY/G,CAAZ,CAAV;;AACJ,SAAK6C,IAAL;AACA,WAAO,IAAP;AACH;;AACD+D,EAAAA,OAAO,CAACxH,GAAD,EAAMC,IAAN,EAAY;AACf,SAAK,IAAI6C,GAAT,IAAgB,KAAK6E,IAArB,EACI7E,GAAG,CAAC0E,OAAJ,CAAYxH,GAAZ,EAAiBC,IAAjB;;AACJ,SAAK,IAAIW,CAAC,GAAG,KAAK+G,IAAL,CAAU7H,MAAV,IAAoB,CAAjC,EAAoCc,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C,EACIgH,UAAU,CAAC,KAAKD,IAAN,EAAY/G,CAAZ,CAAV;;AACJ,QAAI,CAAC,KAAK7B,EAAL,GAAUiB,GAAV,IAAiB,KAAKR,KAAL,CAAWL,OAAX,GAAqBc,IAAvC,IAA+C,CAAnD,EACI,KAAKwD,IAAL;AACP;;AACDA,EAAAA,IAAI,GAAG;AACH,QAAI,KAAKkE,IAAL,CAAU7H,MAAV,IAAoB,CAAxB,EAA2B;AACvB,WAAKhB,IAAL,GAAY,KAAKC,EAAL,GAAU;AAAW;AAAjC;AACA,WAAKS,KAAL,GAAa,IAAb;AACA,WAAK8H,IAAL,GAAY,CAAC,CAAb;AACH,KAJD,MAKK;AACD,UAAIO,GAAG,GAAG,KAAKF,IAAL,CAAU,CAAV,CAAV;AACA,WAAK7I,IAAL,GAAY+I,GAAG,CAAC/I,IAAhB;AACA,WAAKC,EAAL,GAAU8I,GAAG,CAAC9I,EAAd;AACA,WAAKS,KAAL,GAAaqI,GAAG,CAACrI,KAAjB;AACA,WAAK8H,IAAL,GAAYO,GAAG,CAACP,IAAhB;AACA,UAAIO,GAAG,CAACrI,KAAR,EACIqI,GAAG,CAACpE,IAAJ;AACJmE,MAAAA,UAAU,CAAC,KAAKD,IAAN,EAAY,CAAZ,CAAV;AACH;AACJ;;AA/CY;;AAiDjB,SAASC,UAAT,CAAoBD,IAApB,EAA0BvF,KAA1B,EAAiC;AAC7B,OAAK,IAAIU,GAAG,GAAG6E,IAAI,CAACvF,KAAD,CAAnB,IAA8B;AAC1B,QAAI0F,UAAU,GAAG,CAAC1F,KAAK,IAAI,CAAV,IAAe,CAAhC;AACA,QAAI0F,UAAU,IAAIH,IAAI,CAAC7H,MAAvB,EACI;AACJ,QAAIiI,KAAK,GAAGJ,IAAI,CAACG,UAAD,CAAhB;;AACA,QAAIA,UAAU,GAAG,CAAb,GAAiBH,IAAI,CAAC7H,MAAtB,IAAgCiI,KAAK,CAAC7D,OAAN,CAAcyD,IAAI,CAACG,UAAU,GAAG,CAAd,CAAlB,KAAuC,CAA3E,EAA8E;AAC1EC,MAAAA,KAAK,GAAGJ,IAAI,CAACG,UAAU,GAAG,CAAd,CAAZ;AACAA,MAAAA,UAAU;AACb;;AACD,QAAIhF,GAAG,CAACoB,OAAJ,CAAY6D,KAAZ,IAAqB,CAAzB,EACI;AACJJ,IAAAA,IAAI,CAACG,UAAD,CAAJ,GAAmBhF,GAAnB;AACA6E,IAAAA,IAAI,CAACvF,KAAD,CAAJ,GAAc2F,KAAd;AACA3F,IAAAA,KAAK,GAAG0F,UAAR;AACH;AACJ;;AACD,MAAMlD,UAAN,CAAiB;AACbrF,EAAAA,WAAW,CAAC0E,IAAD,EAAOmD,IAAP,EAAaC,QAAb,EAAiD;AAAA,QAA1B7B,WAA0B,uEAAZ,MAAM,IAAM;AACxD,SAAK6B,QAAL,GAAgBA,QAAhB;AACA,SAAK7B,WAAL,GAAmBA,WAAnB;AACA,SAAKL,MAAL,GAAc,EAAd;AACA,SAAK6C,QAAL,GAAgB,EAAhB;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACA,SAAKC,SAAL,GAAiB,CAAC,CAAlB,CANwD,CAOxD;;AACA,SAAK9I,KAAL,GAAa,IAAb;AACA,SAAK+I,SAAL,GAAiB,CAAjB;AACA,SAAKC,SAAL,GAAiB,CAAjB;AACA,SAAKrJ,EAAL,GAAU,CAAC;AAAW;AAAtB;AACA,SAAKI,OAAL,GAAe,CAAf;AACA,SAAKwG,SAAL,GAAiB,CAAC,CAAlB;AACA,SAAKJ,MAAL,GAAcvB,UAAU,CAAClF,IAAX,CAAgBmF,IAAhB,EAAsBmD,IAAtB,EAA4BC,QAA5B,CAAd;AACH;;AACDrE,EAAAA,IAAI,CAAChD,GAAD,EAAoC;AAAA,QAA9BC,IAA8B,uEAAvB,CAAC,UAAsB;AACpC,SAAKsF,MAAL,CAAYvC,IAAZ,CAAiBhD,GAAjB,EAAsBC,IAAtB;AACA,SAAKkF,MAAL,CAAYrF,MAAZ,GAAqB,KAAKkI,QAAL,CAAclI,MAAd,GAAuB,KAAKmI,UAAL,CAAgBnI,MAAhB,GAAyB,CAArE;AACA,SAAKoI,SAAL,GAAiB,CAAC,CAAlB;AACA,SAAKnJ,EAAL,GAAUiB,GAAV;AACA,SAAKb,OAAL,GAAec,IAAf;AACA,SAAK0F,SAAL,GAAiB,CAAC,CAAlB;AACA,SAAKlC,IAAL;AACA,WAAO,IAAP;AACH;;AACD+D,EAAAA,OAAO,CAACxH,GAAD,EAAMC,IAAN,EAAY;AACf,WAAO,KAAKiI,SAAL,GAAiB,CAAC,CAAlB,IAAuB,CAAC,KAAKF,QAAL,CAAc,KAAKE,SAAnB,IAAgClI,GAAhC,IAAuC,KAAKmF,MAAL,CAAY,KAAK+C,SAAjB,EAA4B/I,OAA5B,GAAsCc,IAA9E,IAAsF,CAApH,EACI,KAAKoI,YAAL,CAAkB,KAAKH,SAAvB;;AACJ,SAAK3C,MAAL,CAAYiC,OAAZ,CAAoBxH,GAApB,EAAyBC,IAAzB;AACH;;AACDoI,EAAAA,YAAY,CAACjG,KAAD,EAAQ;AAChBkG,IAAAA,MAAM,CAAC,KAAKnD,MAAN,EAAc/C,KAAd,CAAN;AACAkG,IAAAA,MAAM,CAAC,KAAKN,QAAN,EAAgB5F,KAAhB,CAAN;AACAkG,IAAAA,MAAM,CAAC,KAAKL,UAAN,EAAkB7F,KAAlB,CAAN;AACA,SAAK8F,SAAL,GAAiBK,YAAY,CAAC,KAAKpD,MAAN,EAAc,KAAK6C,QAAnB,CAA7B;AACH;;AACDQ,EAAAA,SAAS,CAACC,SAAD,EAAY;AACjB,QAAI7H,CAAC,GAAG,CAAR;AAAA,QAAW;AAAEpB,MAAAA,KAAF;AAAST,MAAAA,EAAT;AAAauI,MAAAA;AAAb,QAAsB,KAAK/B,MAAtC;;AACA,WAAO3E,CAAC,GAAG,KAAKqH,UAAL,CAAgBnI,MAApB,IAA8B,KAAKmI,UAAL,CAAgBrH,CAAhB,KAAsB0G,IAA3D,EACI1G,CAAC;;AACL8H,IAAAA,MAAM,CAAC,KAAKvD,MAAN,EAAcvE,CAAd,EAAiBpB,KAAjB,CAAN;AACAkJ,IAAAA,MAAM,CAAC,KAAKV,QAAN,EAAgBpH,CAAhB,EAAmB7B,EAAnB,CAAN;AACA2J,IAAAA,MAAM,CAAC,KAAKT,UAAN,EAAkBrH,CAAlB,EAAqB0G,IAArB,CAAN;AACA,QAAImB,SAAJ,EACIC,MAAM,CAACD,SAAD,EAAY7H,CAAZ,EAAe,KAAK2E,MAAL,CAAYzG,IAA3B,CAAN;AACJ,SAAKoJ,SAAL,GAAiBK,YAAY,CAAC,KAAKpD,MAAN,EAAc,KAAK6C,QAAnB,CAA7B;AACH,GAhDY,CAiDb;AACA;;;AACAvE,EAAAA,IAAI,GAAG;AACH,QAAI3E,IAAI,GAAG,KAAKC,EAAhB;AAAA,QAAoB4J,QAAQ,GAAG,KAAKvJ,KAApC;AACA,SAAKA,KAAL,GAAa,IAAb;AACA,QAAIqJ,SAAS,GAAG,KAAK9C,SAAL,GAAiB,CAAjB,GAAqB,EAArB,GAA0B,IAA1C;AAAA,QAAgDiD,UAAU,GAAG,CAA7D;;AACA,aAAS;AACL,UAAIlJ,CAAC,GAAG,KAAKwI,SAAb;;AACA,UAAIxI,CAAC,GAAG,CAAC,CAAL,IAAU,CAAC,KAAKsI,QAAL,CAActI,CAAd,IAAmB,KAAK6F,MAAL,CAAYzG,IAA/B,IAAuC,KAAKqG,MAAL,CAAYzF,CAAZ,EAAeP,OAAf,GAAyB,KAAKoG,MAAL,CAAYrG,SAA7E,IAA0F,CAAxG,EAA2G;AACvG,YAAI,KAAK8I,QAAL,CAActI,CAAd,IAAmBZ,IAAvB,EAA6B;AACzB,eAAKC,EAAL,GAAU,KAAKiJ,QAAL,CAActI,CAAd,CAAV;AACA,eAAKP,OAAL,GAAe,KAAKgG,MAAL,CAAYzF,CAAZ,EAAeP,OAA9B;AACA;AACH;;AACD,aAAKkJ,YAAL,CAAkB3I,CAAlB;AACA,YAAI+I,SAAJ,EACIH,MAAM,CAACG,SAAD,EAAY/I,CAAZ,CAAN;AACP,OATD,MAUK,IAAI,CAAC,KAAK6F,MAAL,CAAY/F,KAAjB,EAAwB;AACzB,aAAKT,EAAL,GAAU,KAAKI,OAAL,GAAe;AAAW;AAApC;AACA;AACH,OAHI,MAIA,IAAI,KAAKoG,MAAL,CAAYzG,IAAZ,GAAmBA,IAAvB,EAA6B;AAC9B,aAAKC,EAAL,GAAU,KAAKwG,MAAL,CAAYzG,IAAtB;AACA,aAAKK,OAAL,GAAe,KAAKoG,MAAL,CAAYrG,SAA3B;AACA;AACH,OAJI,MAKA;AACD,YAAI2J,OAAO,GAAG,KAAKtD,MAAL,CAAY/F,KAA1B;;AACA,YAAI,CAACqJ,OAAO,CAACzJ,KAAb,EAAoB;AAAE;AAClB,eAAKoJ,SAAL,CAAeC,SAAf;AACA,eAAKlD,MAAL,CAAY9B,IAAZ;AACH,SAHD,MAIK,IAAIkF,QAAQ,IAAI,KAAKpD,MAAL,CAAYxG,EAAZ,IAAkB,KAAKA,EAAnC,IAAyC,KAAKwG,MAAL,CAAYzG,IAAZ,GAAmB,KAAKyG,MAAL,CAAYxG,EAA5E,EAAgF;AACjF;AACA,eAAKwG,MAAL,CAAY9B,IAAZ;AACH,SAHI,MAIA,IAAI,CAAC,KAAK+B,WAAL,CAAiB,KAAKD,MAAL,CAAYzG,IAA7B,EAAmC,KAAKyG,MAAL,CAAYxG,EAA/C,EAAmD,KAAKwG,MAAL,CAAY/F,KAA/D,EAAsE,KAAK+F,MAAL,CAAY+B,IAAlF,CAAL,EAA8F;AAC/F,eAAK/B,MAAL,CAAY9B,IAAZ;AACH,SAFI,MAGA;AAAE;AACH,eAAKrE,KAAL,GAAayJ,OAAb;AACA,eAAKV,SAAL,GAAiB,KAAK5C,MAAL,CAAYzG,IAA7B;AACA,eAAKsJ,SAAL,GAAiB,KAAK7C,MAAL,CAAY+B,IAA7B;AACA,eAAKvI,EAAL,GAAU,KAAKwG,MAAL,CAAYxG,EAAtB;AACA,eAAKI,OAAL,GAAe0J,OAAO,CAAC1J,OAAvB;AACA,cAAI,KAAKoG,MAAL,CAAYzG,IAAZ,GAAmBA,IAAvB,EACI8J,UAAU,GAAG,CAAb;AACJ,eAAKrD,MAAL,CAAY9B,IAAZ;AACA,cAAI,KAAK1E,EAAL,GAAUD,IAAd,EACI,KAAK0I,OAAL,CAAa,KAAKzI,EAAlB,EAAsB,KAAKI,OAA3B;AACJ;AACH;AACJ;AACJ;;AACD,QAAIsJ,SAAJ,EAAe;AACX,UAAI9C,SAAS,GAAG,CAAhB;;AACA,aAAOA,SAAS,GAAG8C,SAAS,CAAC3I,MAAtB,IAAgC2I,SAAS,CAAC9C,SAAD,CAAT,GAAuB7G,IAA9D,EACI6G,SAAS;;AACb,WAAKA,SAAL,GAAiBA,SAAS,GAAGiD,UAA7B;AACH;AACJ;;AACD/C,EAAAA,cAAc,CAAC9G,EAAD,EAAK;AACf,QAAI,CAAC,KAAKoG,MAAL,CAAYrF,MAAjB,EACI,OAAO,KAAKqF,MAAZ;AACJ,QAAIA,MAAM,GAAG,EAAb;;AACA,SAAK,IAAIvE,CAAC,GAAG,KAAKuE,MAAL,CAAYrF,MAAZ,GAAqB,CAAlC,EAAqCc,CAAC,IAAI,CAA1C,EAA6CA,CAAC,EAA9C,EAAkD;AAC9C,UAAI,KAAKqH,UAAL,CAAgBrH,CAAhB,IAAqB,KAAKwH,SAA9B,EACI;AACJ,UAAI,KAAKJ,QAAL,CAAcpH,CAAd,IAAmB7B,EAAnB,IAAyB,KAAKiJ,QAAL,CAAcpH,CAAd,KAAoB7B,EAApB,IAA0B,KAAKoG,MAAL,CAAYvE,CAAZ,EAAezB,OAAf,IAA0B,KAAKC,KAAL,CAAWD,OAA5F,EACIgG,MAAM,CAACzD,IAAP,CAAY,KAAKyD,MAAL,CAAYvE,CAAZ,CAAZ;AACP;;AACD,WAAOuE,MAAM,CAAC2D,OAAP,EAAP;AACH;;AACDhD,EAAAA,OAAO,CAAC/G,EAAD,EAAK;AACR,QAAI2G,IAAI,GAAG,CAAX;;AACA,SAAK,IAAI9E,CAAC,GAAG,KAAKoH,QAAL,CAAclI,MAAd,GAAuB,CAApC,EAAuCc,CAAC,IAAI,CAAL,IAAU,KAAKoH,QAAL,CAAcpH,CAAd,IAAmB7B,EAApE,EAAwE6B,CAAC,EAAzE,EACI8E,IAAI;;AACR,WAAOA,IAAP;AACH;;AAhIY;;AAkIjB,SAASxB,OAAT,CAAiBxE,CAAjB,EAAoBqJ,MAApB,EAA4BpJ,CAA5B,EAA+BqJ,MAA/B,EAAuClJ,MAAvC,EAA+CwE,UAA/C,EAA2D;AACvD5E,EAAAA,CAAC,CAACsD,IAAF,CAAO+F,MAAP;AACApJ,EAAAA,CAAC,CAACqD,IAAF,CAAOgG,MAAP;AACA,MAAIC,IAAI,GAAGD,MAAM,GAAGlJ,MAApB;AACA,MAAIE,GAAG,GAAGgJ,MAAV;AAAA,MAAkBE,IAAI,GAAGF,MAAM,GAAGD,MAAlC;;AACA,WAAS;AACL,QAAIvI,IAAI,GAAId,CAAC,CAACX,EAAF,GAAOmK,IAAR,GAAgBvJ,CAAC,CAACZ,EAAlB,IAAwBW,CAAC,CAACP,OAAF,GAAYQ,CAAC,CAACR,OAAjD;AACA,QAAIe,GAAG,GAAGM,IAAI,GAAG,CAAP,GAAWd,CAAC,CAACX,EAAF,GAAOmK,IAAlB,GAAyBvJ,CAAC,CAACZ,EAArC;AAAA,QAAyCoK,OAAO,GAAG3H,IAAI,CAACoE,GAAL,CAAS1F,GAAT,EAAc+I,IAAd,CAAnD;;AACA,QAAIvJ,CAAC,CAACN,KAAF,IAAWO,CAAC,CAACP,KAAjB,EAAwB;AACpB,UAAI,EAAEM,CAAC,CAACN,KAAF,IAAWO,CAAC,CAACP,KAAb,KAAuBM,CAAC,CAACN,KAAF,IAAWO,CAAC,CAACP,KAAb,IAAsBM,CAAC,CAACN,KAAF,CAAQT,EAAR,CAAWgB,CAAC,CAACP,KAAb,CAA7C,KACF8F,UAAU,CAACxF,CAAC,CAACmG,cAAF,CAAiBnG,CAAC,CAACX,EAAF,GAAOmK,IAAxB,CAAD,EAAgCvJ,CAAC,CAACkG,cAAF,CAAiBlG,CAAC,CAACZ,EAAnB,CAAhC,CADV,CAAJ,EAEIuF,UAAU,CAAC8E,YAAX,CAAwBpJ,GAAxB,EAA6BmJ,OAA7B,EAAsCzJ,CAAC,CAACN,KAAxC,EAA+CO,CAAC,CAACP,KAAjD;AACP,KAJD,MAKK;AACD,UAAI+J,OAAO,GAAGnJ,GAAV,IAAiB,CAACkF,UAAU,CAACxF,CAAC,CAACyF,MAAH,EAAWxF,CAAC,CAACwF,MAAb,CAAhC,EACIb,UAAU,CAAC+E,YAAX,CAAwBrJ,GAAxB,EAA6BmJ,OAA7B,EAAsCzJ,CAAC,CAACyF,MAAxC,EAAgDxF,CAAC,CAACwF,MAAlD;AACP;;AACD,QAAIjF,GAAG,GAAG+I,IAAV,EACI;AACJjJ,IAAAA,GAAG,GAAGE,GAAN;AACA,QAAIM,IAAI,IAAI,CAAZ,EACId,CAAC,CAAC+D,IAAF;AACJ,QAAIjD,IAAI,IAAI,CAAZ,EACIb,CAAC,CAAC8D,IAAF;AACP;AACJ;;AACD,SAASyB,UAAT,CAAoBxF,CAApB,EAAuBC,CAAvB,EAA0B;AACtB,MAAID,CAAC,CAACI,MAAF,IAAYH,CAAC,CAACG,MAAlB,EACI,OAAO,KAAP;;AACJ,OAAK,IAAIc,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlB,CAAC,CAACI,MAAtB,EAA8Bc,CAAC,EAA/B,EACI,IAAIlB,CAAC,CAACkB,CAAD,CAAD,IAAQjB,CAAC,CAACiB,CAAD,CAAT,IAAgB,CAAClB,CAAC,CAACkB,CAAD,CAAD,CAAKjC,EAAL,CAAQgB,CAAC,CAACiB,CAAD,CAAT,CAArB,EACI,OAAO,KAAP;;AACR,SAAO,IAAP;AACH;;AACD,SAAS0H,MAAT,CAAgBgB,KAAhB,EAAuBlH,KAAvB,EAA8B;AAC1B,OAAK,IAAIxB,CAAC,GAAGwB,KAAR,EAAevB,CAAC,GAAGyI,KAAK,CAACxJ,MAAN,GAAe,CAAvC,EAA0Cc,CAAC,GAAGC,CAA9C,EAAiDD,CAAC,EAAlD,EACI0I,KAAK,CAAC1I,CAAD,CAAL,GAAW0I,KAAK,CAAC1I,CAAC,GAAG,CAAL,CAAhB;;AACJ0I,EAAAA,KAAK,CAACC,GAAN;AACH;;AACD,SAASb,MAAT,CAAgBY,KAAhB,EAAuBlH,KAAvB,EAA8B5C,KAA9B,EAAqC;AACjC,OAAK,IAAIoB,CAAC,GAAG0I,KAAK,CAACxJ,MAAN,GAAe,CAA5B,EAA+Bc,CAAC,IAAIwB,KAApC,EAA2CxB,CAAC,EAA5C,EACI0I,KAAK,CAAC1I,CAAC,GAAG,CAAL,CAAL,GAAe0I,KAAK,CAAC1I,CAAD,CAApB;;AACJ0I,EAAAA,KAAK,CAAClH,KAAD,CAAL,GAAe5C,KAAf;AACH;;AACD,SAAS+I,YAAT,CAAsB/I,KAAtB,EAA6B8J,KAA7B,EAAoC;AAChC,MAAIE,KAAK,GAAG,CAAC,CAAb;AAAA,MAAgBC,QAAQ,GAAG;AAAW;AAAtC;;AACA,OAAK,IAAI7I,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0I,KAAK,CAACxJ,MAA1B,EAAkCc,CAAC,EAAnC,EACI,IAAI,CAAC0I,KAAK,CAAC1I,CAAD,CAAL,GAAW6I,QAAX,IAAuBjK,KAAK,CAACoB,CAAD,CAAL,CAASzB,OAAT,GAAmBK,KAAK,CAACgK,KAAD,CAAL,CAAarK,OAAxD,IAAmE,CAAvE,EAA0E;AACtEqK,IAAAA,KAAK,GAAG5I,CAAR;AACA6I,IAAAA,QAAQ,GAAGH,KAAK,CAAC1I,CAAD,CAAhB;AACH;;AACL,SAAO4I,KAAP;AACH;;AAED,SAASxK,KAAT,EAAgB2C,QAAhB,EAA0BwB,eAA1B,EAA2CzE,UAA3C","sourcesContent":["import { MapMode } from '@codemirror/state';\n\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/\nclass RangeValue {\n    /**\n    Compare this value with another value. The default\n    implementation compares by identity.\n    */\n    eq(other) { return this == other; }\n    /**\n    Create a [range](https://codemirror.net/6/docs/ref/#rangeset.Range) with this value.\n    */\n    range(from, to = from) { return new Range(from, to, this); }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/\nclass Range {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The range's start position.\n    */\n    from, \n    /**\n    Its end position.\n    */\n    to, \n    /**\n    The value associated with this range.\n    */\n    value) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n    constructor(from, to, value, \n    // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() { return this.to[this.to.length - 1]; }\n    // Find the index of the given position and side. Use the ranges'\n    // `from` pos when `end == false`, `to` when `end == true`.\n    findIndex(pos, side, end, startAt = 0) {\n        let arr = end ? this.to : this.from;\n        for (let lo = startAt, hi = arr.length;;) {\n            if (lo == hi)\n                return lo;\n            let mid = (lo + hi) >> 1;\n            let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;\n            if (mid == lo)\n                return diff >= 0 ? lo : hi;\n            if (diff >= 0)\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for (let i = this.findIndex(from, -1000000000 /* Far */, true), e = this.findIndex(to, 1000000000 /* Far */, false, i); i < e; i++)\n            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)\n                return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for (let i = 0; i < this.value.length; i++) {\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n            if (curFrom == curTo) {\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n                if (mapped == null)\n                    continue;\n                newFrom = newTo = mapped;\n                if (val.startSide != val.endSide) {\n                    newTo = changes.mapPos(curFrom, val.endSide);\n                    if (newTo < newFrom)\n                        continue;\n                }\n            }\n            else {\n                newFrom = changes.mapPos(curFrom, val.startSide);\n                newTo = changes.mapPos(curTo, val.endSide);\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)\n                    continue;\n            }\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0)\n                continue;\n            if (newPos < 0)\n                newPos = newFrom;\n            if (val.point)\n                maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };\n    }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#rangeset.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.update). This is an immutable data\nstructure.\n*/\nclass RangeSet {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    chunkPos, \n    /**\n    @internal\n    */\n    chunk, \n    /**\n    @internal\n    */\n    nextLayer = RangeSet.empty, \n    /**\n    @internal\n    */\n    maxPoint) {\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /**\n    @internal\n    */\n    get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /**\n    The number of ranges in the set.\n    */\n    get size() {\n        if (this.isEmpty)\n            return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)\n            size += chunk.value.length;\n        return size;\n    }\n    /**\n    @internal\n    */\n    chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /**\n    Update the range set, optionally adding new ranges or filtering\n    out existing ones.\n    \n    (The extra type parameter is just there as a kludge to work\n    around TypeScript variance issues that prevented `RangeSet<X>`\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    `Y`.)\n    */\n    update(updateSpec) {\n        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;\n        let filter = updateSpec.filter;\n        if (add.length == 0 && !filter)\n            return this;\n        if (sort)\n            add.slice().sort(cmpRange);\n        if (this.isEmpty)\n            return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while (cur.value || i < add.length) {\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value))\n                    spill.push(range);\n            }\n            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&\n                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&\n                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&\n                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            }\n            else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value))\n                        spill.push(new Range(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer.isEmpty && !spill.length ? RangeSet.empty\n            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));\n    }\n    /**\n    Map this range set through a set of changes, return the new set.\n    */\n    map(changes) {\n        if (changes.length == 0 || this.isEmpty)\n            return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            }\n            else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);\n    }\n    /**\n    Iterate over the ranges that touch the region `from` to `to`,\n    calling `f` for each. There is no guarantee that the ranges will\n    be reported in any specific order. When the callback returns\n    `false`, iteration stops.\n    */\n    between(from, to, f) {\n        if (this.isEmpty)\n            return;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length &&\n                chunk.between(start, from - start, to - start, f) === false)\n                return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /**\n    Iterate over the ranges in this set, in order, including all\n    ranges that end at or after `from`.\n    */\n    iter(from = 0) {\n        return HeapCursor.from([this]).goto(from);\n    }\n    /**\n    @internal\n    */\n    get isEmpty() { return this.nextLayer == this; }\n    /**\n    Iterate over the ranges in a collection of sets, in order,\n    starting from `from`.\n    */\n    static iter(sets, from = 0) {\n        return HeapCursor.from(sets).goto(from);\n    }\n    /**\n    Iterate over two groups of sets, calling methods on `comparator`\n    to notify it of possible differences.\n    */\n    static compare(oldSets, newSets, \n    /**\n    This indicates how the underlying data changed between these\n    ranges, and is needed to synchronize the iteration. `from` and\n    `to` are coordinates in the _new_ space, after these changes.\n    */\n    textDiff, comparator, \n    /**\n    Can be used to ignore all non-point ranges, and points below\n    the given size. When -1, all ranges are compared.\n    */\n    minPointSize = -1) {\n        let a = oldSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let b = newSets.filter(set => set.maxPoint > 0 || !set.isEmpty && set.maxPoint >= minPointSize);\n        let sharedChunks = findSharedChunks(a, b, textDiff);\n        let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n        let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n        if (textDiff.empty && textDiff.length == 0)\n            compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /**\n    Compare the contents of two groups of range sets, returning true\n    if they are equivalent in the given range.\n    */\n    static eq(oldSets, newSets, from = 0, to) {\n        if (to == null)\n            to = 1000000000 /* Far */;\n        let a = oldSets.filter(set => !set.isEmpty && newSets.indexOf(set) < 0);\n        let b = newSets.filter(set => !set.isEmpty && oldSets.indexOf(set) < 0);\n        if (a.length != b.length)\n            return false;\n        if (!a.length)\n            return true;\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);\n        for (;;) {\n            if (sideA.to != sideB.to ||\n                !sameValues(sideA.active, sideB.active) ||\n                sideA.point && (!sideB.point || !sideA.point.eq(sideB.point)))\n                return false;\n            if (sideA.to > to)\n                return true;\n            sideA.next();\n            sideB.next();\n        }\n    }\n    /**\n    Iterate over a group of range sets at the same time, notifying\n    the iterator about the ranges covering every given piece of\n    content. Returns the open count (see\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#rangeset.SpanIterator.span)) at the end\n    of the iteration.\n    */\n    static spans(sets, from, to, iterator, \n    /**\n    When given and greater than -1, only points of at least this\n    size are taken into account.\n    */\n    minPointSize = -1) {\n        var _a;\n        let cursor = new SpanCursor(sets, null, minPointSize, (_a = iterator.filterPoint) === null || _a === void 0 ? void 0 : _a.bind(iterator)).goto(from), pos = from;\n        let open = cursor.openStart;\n        for (;;) {\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point) {\n                iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);\n                open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);\n            }\n            else if (curTo > pos) {\n                iterator.span(pos, curTo, cursor.active, open);\n                open = cursor.openEnd(curTo);\n            }\n            if (cursor.to > to)\n                break;\n            pos = cursor.to;\n            cursor.next();\n        }\n        return open;\n    }\n    /**\n    Create a range set for the given range or array of ranges. By\n    default, this expects the ranges to be _sorted_ (by start\n    position and, if two start at the same position,\n    `value.startSide`). You can pass `true` as second argument to\n    cause the method to sort them.\n    */\n    static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)\n            build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n}\n/**\nThe empty set of ranges.\n*/\nRangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);\nfunction lazySort(ranges) {\n    if (ranges.length > 1)\n        for (let prev = ranges[0], i = 1; i < ranges.length; i++) {\n            let cur = ranges[i];\n            if (cmpRange(prev, cur) > 0)\n                return ranges.slice().sort(cmpRange);\n            prev = cur;\n        }\n    return ranges;\n}\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#rangeset.Range) objects.\n*/\nclass RangeSetBuilder {\n    /**\n    Create an empty builder.\n    */\n    constructor() {\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -1000000000 /* Far */;\n        this.lastTo = -1000000000 /* Far */;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /**\n    Add a range. Ranges should be added in sorted (by `from` and\n    `value.startSide`) order.\n    */\n    add(from, to, value) {\n        if (!this.addInner(from, to, value))\n            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /**\n    @internal\n    */\n    addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)\n            throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0)\n            return false;\n        if (this.from.length == 250 /* ChunkSize */)\n            this.finishChunk(true);\n        if (this.chunkStart < 0)\n            this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point)\n            this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /**\n    @internal\n    */\n    addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)\n            return false;\n        if (this.from.length)\n            this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /**\n    Finish the range set. Returns the new set. The builder can't be\n    used anymore after this has been called.\n    */\n    finish() { return this.finishInner(RangeSet.empty); }\n    /**\n    @internal\n    */\n    finishInner(next) {\n        if (this.from.length)\n            this.finishChunk(false);\n        if (this.chunks.length == 0)\n            return next;\n        let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b, textDiff) {\n    let inA = new Map();\n    for (let set of a)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (set.chunk[i].maxPoint <= 0)\n                inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)\n        for (let i = 0; i < set.chunk.length; i++) {\n            let known = inA.get(set.chunk[i]);\n            if (known != null && (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] &&\n                !(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))\n                shared.add(set.chunk[i]);\n        }\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint, rank = 0) {\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n        this.rank = rank;\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    get endSide() { return this.value ? this.value.endSide : 0; }\n    goto(pos, side = -1000000000 /* Far */) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while (this.chunkIndex < this.layer.chunk.length) {\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) ||\n                this.layer.chunkEnd(this.chunkIndex) < pos ||\n                next.maxPoint < this.minPoint))\n                break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        if (this.chunkIndex < this.layer.chunk.length) {\n            let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);\n            if (!forward || this.rangeIndex < rangeIndex)\n                this.setRangeIndex(rangeIndex);\n        }\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0)\n            this.gotoInner(pos, side, true);\n    }\n    next() {\n        for (;;) {\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = 1000000000 /* Far */;\n                this.value = null;\n                break;\n            }\n            else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                this.setRangeIndex(this.rangeIndex + 1);\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)\n                    break;\n            }\n        }\n    }\n    setRangeIndex(index) {\n        if (index == this.layer.chunk[this.chunkIndex].value.length) {\n            this.chunkIndex++;\n            if (this.skip) {\n                while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))\n                    this.chunkIndex++;\n            }\n            this.rangeIndex = 0;\n        }\n        else {\n            this.rangeIndex = index;\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap) {\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for (let i = 0; i < sets.length; i++) {\n            for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {\n                if (cur.maxPoint >= minPoint)\n                    heap.push(new LayerCursor(cur, skip, minPoint, i));\n            }\n        }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    goto(pos, side = -1000000000 /* Far */) {\n        for (let cur of this.heap)\n            cur.goto(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)\n            cur.forward(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0)\n            this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = 1000000000 /* Far */;\n            this.value = null;\n            this.rank = -1;\n        }\n        else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            this.rank = top.rank;\n            if (top.value)\n                top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for (let cur = heap[index];;) {\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length)\n            break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0)\n            break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint, filterPoint = () => true) {\n        this.minPoint = minPoint;\n        this.filterPoint = filterPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.activeRank = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.pointRank = 0;\n        this.to = -1000000000 /* Far */;\n        this.endSide = 0;\n        this.openStart = -1;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -1000000000 /* Far */) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.openStart = -1;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)\n            this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        remove(this.activeRank, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    addActive(trackOpen) {\n        let i = 0, { value, to, rank } = this.cursor;\n        while (i < this.activeRank.length && this.activeRank[i] <= rank)\n            i++;\n        insert(this.active, i, value);\n        insert(this.activeTo, i, to);\n        insert(this.activeRank, i, rank);\n        if (trackOpen)\n            insert(trackOpen, i, this.cursor.from);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to, wasPoint = this.point;\n        this.point = null;\n        let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;\n        for (;;) {\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n                if (trackOpen)\n                    remove(trackOpen, a);\n            }\n            else if (!this.cursor.value) {\n                this.to = this.endSide = 1000000000 /* Far */;\n                break;\n            }\n            else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            }\n            else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) { // Opening a range\n                    this.addActive(trackOpen);\n                    this.cursor.next();\n                }\n                else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to) {\n                    // Ignore any non-empty points that end precisely at the end of the prev point\n                    this.cursor.next();\n                }\n                else if (!this.filterPoint(this.cursor.from, this.cursor.to, this.cursor.value, this.cursor.rank)) {\n                    this.cursor.next();\n                }\n                else { // New point\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.pointRank = this.cursor.rank;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    if (this.cursor.from < from)\n                        trackExtra = 1;\n                    this.cursor.next();\n                    if (this.to > from)\n                        this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n        if (trackOpen) {\n            let openStart = 0;\n            while (openStart < trackOpen.length && trackOpen[openStart] < from)\n                openStart++;\n            this.openStart = openStart + trackExtra;\n        }\n    }\n    activeForPoint(to) {\n        if (!this.active.length)\n            return this.active;\n        let active = [];\n        for (let i = this.active.length - 1; i >= 0; i--) {\n            if (this.activeRank[i] < this.pointRank)\n                break;\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide >= this.point.endSide)\n                active.push(this.active[i]);\n        }\n        return active.reverse();\n    }\n    openEnd(to) {\n        let open = 0;\n        for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > to; i--)\n            open++;\n        return open;\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for (;;) {\n        let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)) &&\n                sameValues(a.activeForPoint(a.to + dPos), b.activeForPoint(b.to))))\n                comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        }\n        else {\n            if (clipEnd > pos && !sameValues(a.active, b.active))\n                comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB)\n            break;\n        pos = end;\n        if (diff <= 0)\n            a.next();\n        if (diff >= 0)\n            b.next();\n    }\n}\nfunction sameValues(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i] && !a[i].eq(b[i]))\n            return false;\n    return true;\n}\nfunction remove(array, index) {\n    for (let i = index, e = array.length - 1; i < e; i++)\n        array[i] = array[i + 1];\n    array.pop();\n}\nfunction insert(array, index, value) {\n    for (let i = array.length - 1; i >= index; i--)\n        array[i + 1] = array[i];\n    array[index] = value;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = 1000000000 /* Far */;\n    for (let i = 0; i < array.length; i++)\n        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n            found = i;\n            foundPos = array[i];\n        }\n    return found;\n}\n\nexport { Range, RangeSet, RangeSetBuilder, RangeValue };\n"]},"metadata":{},"sourceType":"module"}