{"ast":null,"code":"import { EditorSelection } from '@codemirror/state';\nimport { EditorView } from '@codemirror/view';\nimport { findColumn, countColumn } from '@codemirror/text'; // Don't compute precise column positions for line offsets above this\n// (since it could get expensive). Assume offset==column for them.\n\nconst MaxOff = 2000;\n\nfunction rectangleFor(state, a, b) {\n  let startLine = Math.min(a.line, b.line),\n      endLine = Math.max(a.line, b.line);\n  let ranges = [];\n\n  if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\n    let startOff = Math.min(a.off, b.off),\n        endOff = Math.max(a.off, b.off);\n\n    for (let i = startLine; i <= endLine; i++) {\n      let line = state.doc.line(i);\n      if (line.length <= endOff) ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));\n    }\n  } else {\n    let startCol = Math.min(a.col, b.col),\n        endCol = Math.max(a.col, b.col);\n\n    for (let i = startLine; i <= endLine; i++) {\n      let line = state.doc.line(i);\n      let start = findColumn(line.text, startCol, state.tabSize, true);\n\n      if (start > -1) {\n        let end = findColumn(line.text, endCol, state.tabSize);\n        ranges.push(EditorSelection.range(line.from + start, line.from + end));\n      }\n    }\n  }\n\n  return ranges;\n}\n\nfunction absoluteColumn(view, x) {\n  let ref = view.coordsAtPos(view.viewport.from);\n  return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\n}\n\nfunction getPos(view, event) {\n  let offset = view.posAtCoords({\n    x: event.clientX,\n    y: event.clientY\n  }, false);\n  let line = view.state.doc.lineAt(offset),\n      off = offset - line.from;\n  let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text, view.state.tabSize, offset - line.from);\n  return {\n    line: line.number,\n    col,\n    off\n  };\n}\n\nfunction rectangleSelectionStyle(view, event) {\n  let start = getPos(view, event),\n      startSel = view.state.selection;\n  if (!start) return null;\n  return {\n    update(update) {\n      if (update.docChanged) {\n        let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);\n        let newLine = update.state.doc.lineAt(newStart);\n        start = {\n          line: newLine.number,\n          col: start.col,\n          off: Math.min(start.off, newLine.length)\n        };\n        startSel = startSel.map(update.changes);\n      }\n    },\n\n    get(event, _extend, multiple) {\n      let cur = getPos(view, event);\n      if (!cur) return startSel;\n      let ranges = rectangleFor(view.state, start, cur);\n      if (!ranges.length) return startSel;\n      if (multiple) return EditorSelection.create(ranges.concat(startSel.ranges));else return EditorSelection.create(ranges);\n    }\n\n  };\n}\n/**\nCreate an extension that enables rectangular selections. By\ndefault, it will react to left mouse drag with the Alt key held\ndown. When such a selection occurs, the text within the rectangle\nthat was dragged over will be selected, as one selection\n[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.\n*/\n\n\nfunction rectangularSelection(options) {\n  let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);\n\n  return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);\n}\n\nexport { rectangularSelection };","map":{"version":3,"sources":["C:/Users/pc/Desktop/live-code-editor/client/node_modules/@codemirror/rectangular-selection/dist/index.js"],"names":["EditorSelection","EditorView","findColumn","countColumn","MaxOff","rectangleFor","state","a","b","startLine","Math","min","line","endLine","max","ranges","off","col","startOff","endOff","i","doc","length","push","range","from","to","startCol","endCol","start","text","tabSize","end","absoluteColumn","view","x","ref","coordsAtPos","viewport","round","abs","left","defaultCharacterWidth","getPos","event","offset","posAtCoords","clientX","y","clientY","lineAt","number","rectangleSelectionStyle","startSel","selection","update","docChanged","newStart","changes","mapPos","startState","newLine","map","get","_extend","multiple","cur","create","concat","rectangularSelection","options","filter","eventFilter","e","altKey","button","mouseSelectionStyle","of"],"mappings":"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","sourcesContent":["import { EditorSelection } from '@codemirror/state';\nimport { EditorView } from '@codemirror/view';\nimport { findColumn, countColumn } from '@codemirror/text';\n\n// Don't compute precise column positions for line offsets above this\n// (since it could get expensive). Assume offset==column for them.\nconst MaxOff = 2000;\nfunction rectangleFor(state, a, b) {\n    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);\n    let ranges = [];\n    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\n        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);\n        for (let i = startLine; i <= endLine; i++) {\n            let line = state.doc.line(i);\n            if (line.length <= endOff)\n                ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));\n        }\n    }\n    else {\n        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);\n        for (let i = startLine; i <= endLine; i++) {\n            let line = state.doc.line(i);\n            let start = findColumn(line.text, startCol, state.tabSize, true);\n            if (start > -1) {\n                let end = findColumn(line.text, endCol, state.tabSize);\n                ranges.push(EditorSelection.range(line.from + start, line.from + end));\n            }\n        }\n    }\n    return ranges;\n}\nfunction absoluteColumn(view, x) {\n    let ref = view.coordsAtPos(view.viewport.from);\n    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\n}\nfunction getPos(view, event) {\n    let offset = view.posAtCoords({ x: event.clientX, y: event.clientY }, false);\n    let line = view.state.doc.lineAt(offset), off = offset - line.from;\n    let col = off > MaxOff ? -1\n        : off == line.length ? absoluteColumn(view, event.clientX)\n            : countColumn(line.text, view.state.tabSize, offset - line.from);\n    return { line: line.number, col, off };\n}\nfunction rectangleSelectionStyle(view, event) {\n    let start = getPos(view, event), startSel = view.state.selection;\n    if (!start)\n        return null;\n    return {\n        update(update) {\n            if (update.docChanged) {\n                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);\n                let newLine = update.state.doc.lineAt(newStart);\n                start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get(event, _extend, multiple) {\n            let cur = getPos(view, event);\n            if (!cur)\n                return startSel;\n            let ranges = rectangleFor(view.state, start, cur);\n            if (!ranges.length)\n                return startSel;\n            if (multiple)\n                return EditorSelection.create(ranges.concat(startSel.ranges));\n            else\n                return EditorSelection.create(ranges);\n        }\n    };\n}\n/**\nCreate an extension that enables rectangular selections. By\ndefault, it will react to left mouse drag with the Alt key held\ndown. When such a selection occurs, the text within the rectangle\nthat was dragged over will be selected, as one selection\n[range](https://codemirror.net/6/docs/ref/#state.SelectionRange) per line.\n*/\nfunction rectangularSelection(options) {\n    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);\n    return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);\n}\n\nexport { rectangularSelection };\n"]},"metadata":{},"sourceType":"module"}