{"ast":null,"code":"import { parser } from '@lezer/rust';\nimport { LRLanguage, indentNodeProp, continuedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { styleTags, tags } from '@codemirror/highlight';\n/**\nA syntax provider based on the [Lezer Rust\nparser](https://github.com/lezer-parser/rust), extended with\nhighlighting and indentation information.\n*/\n\nconst rustLanguage = /*@__PURE__*/LRLanguage.define({\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/indentNodeProp.add({\n      IfExpression: /*@__PURE__*/continuedIndent({\n        except: /^\\s*({|else\\b)/\n      }),\n      \"String BlockComment\": () => -1,\n      \"Statement MatchArm\": /*@__PURE__*/continuedIndent()\n    }), /*@__PURE__*/foldNodeProp.add(type => {\n      if (/(Block|edTokens|List)$/.test(type.name)) return foldInside;\n      if (type.name == \"BlockComment\") return tree => ({\n        from: tree.from + 2,\n        to: tree.to - 2\n      });\n      return undefined;\n    }), /*@__PURE__*/styleTags({\n      \"const macro_rules mod struct union enum type fn impl trait let use crate static\": tags.definitionKeyword,\n      \"pub unsafe async mut extern default move\": tags.modifier,\n      \"for if else loop while match continue break return await\": tags.controlKeyword,\n      \"as in ref\": tags.operatorKeyword,\n      \"where _ crate super dyn\": tags.keyword,\n      \"self\": tags.self,\n      String: tags.string,\n      RawString: /*@__PURE__*/tags.special(tags.string),\n      Boolean: tags.bool,\n      Identifier: tags.variableName,\n      \"CallExpression/Identifier\": /*@__PURE__*/tags.function(tags.variableName),\n      BoundIdentifier: /*@__PURE__*/tags.definition(tags.variableName),\n      LoopLabel: tags.labelName,\n      FieldIdentifier: tags.propertyName,\n      \"CallExpression/FieldExpression/FieldIdentifier\": /*@__PURE__*/tags.function(tags.propertyName),\n      Lifetime: /*@__PURE__*/tags.special(tags.variableName),\n      ScopeIdentifier: tags.namespace,\n      TypeIdentifier: tags.typeName,\n      \"MacroInvocation/Identifier MacroInvocation/ScopedIdentifier/Identifier\": tags.macroName,\n      \"MacroInvocation/TypeIdentifier MacroInvocation/ScopedIdentifier/TypeIdentifier\": tags.macroName,\n      \"\\\"!\\\"\": tags.macroName,\n      UpdateOp: tags.updateOperator,\n      LineComment: tags.lineComment,\n      BlockComment: tags.blockComment,\n      Integer: tags.integer,\n      Float: tags.float,\n      ArithOp: tags.arithmeticOperator,\n      LogicOp: tags.logicOperator,\n      BitOp: tags.bitwiseOperator,\n      CompareOp: tags.compareOperator,\n      \"=\": tags.definitionOperator,\n      \".. ... => ->\": tags.punctuation,\n      \"( )\": tags.paren,\n      \"[ ]\": tags.squareBracket,\n      \"{ }\": tags.brace,\n      \".\": tags.derefOperator,\n      \"&\": tags.operator,\n      \", ; ::\": tags.separator\n    })]\n  }),\n  languageData: {\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    },\n    indentOnInput: /^\\s*(?:\\{|\\})$/\n  }\n});\n/**\nRust language support\n*/\n\nfunction rust() {\n  return new LanguageSupport(rustLanguage);\n}\n\nexport { rust, rustLanguage };","map":{"version":3,"sources":["C:/Users/pc/Desktop/live-code-editor/client/node_modules/@codemirror/lang-rust/dist/index.js"],"names":["parser","LRLanguage","indentNodeProp","continuedIndent","foldNodeProp","foldInside","LanguageSupport","styleTags","tags","rustLanguage","define","configure","props","add","IfExpression","except","type","test","name","tree","from","to","undefined","definitionKeyword","modifier","controlKeyword","operatorKeyword","keyword","self","String","string","RawString","special","Boolean","bool","Identifier","variableName","function","BoundIdentifier","definition","LoopLabel","labelName","FieldIdentifier","propertyName","Lifetime","ScopeIdentifier","namespace","TypeIdentifier","typeName","macroName","UpdateOp","updateOperator","LineComment","lineComment","BlockComment","blockComment","Integer","integer","Float","float","ArithOp","arithmeticOperator","LogicOp","logicOperator","BitOp","bitwiseOperator","CompareOp","compareOperator","definitionOperator","punctuation","paren","squareBracket","brace","derefOperator","operator","separator","languageData","commentTokens","line","block","open","close","indentOnInput","rust"],"mappings":"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","sourcesContent":["import { parser } from '@lezer/rust';\nimport { LRLanguage, indentNodeProp, continuedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { styleTags, tags } from '@codemirror/highlight';\n\n/**\nA syntax provider based on the [Lezer Rust\nparser](https://github.com/lezer-parser/rust), extended with\nhighlighting and indentation information.\n*/\nconst rustLanguage = /*@__PURE__*/LRLanguage.define({\n    parser: /*@__PURE__*/parser.configure({\n        props: [\n            /*@__PURE__*/indentNodeProp.add({\n                IfExpression: /*@__PURE__*/continuedIndent({ except: /^\\s*({|else\\b)/ }),\n                \"String BlockComment\": () => -1,\n                \"Statement MatchArm\": /*@__PURE__*/continuedIndent()\n            }),\n            /*@__PURE__*/foldNodeProp.add(type => {\n                if (/(Block|edTokens|List)$/.test(type.name))\n                    return foldInside;\n                if (type.name == \"BlockComment\")\n                    return tree => ({ from: tree.from + 2, to: tree.to - 2 });\n                return undefined;\n            }),\n            /*@__PURE__*/styleTags({\n                \"const macro_rules mod struct union enum type fn impl trait let use crate static\": tags.definitionKeyword,\n                \"pub unsafe async mut extern default move\": tags.modifier,\n                \"for if else loop while match continue break return await\": tags.controlKeyword,\n                \"as in ref\": tags.operatorKeyword,\n                \"where _ crate super dyn\": tags.keyword,\n                \"self\": tags.self,\n                String: tags.string,\n                RawString: /*@__PURE__*/tags.special(tags.string),\n                Boolean: tags.bool,\n                Identifier: tags.variableName,\n                \"CallExpression/Identifier\": /*@__PURE__*/tags.function(tags.variableName),\n                BoundIdentifier: /*@__PURE__*/tags.definition(tags.variableName),\n                LoopLabel: tags.labelName,\n                FieldIdentifier: tags.propertyName,\n                \"CallExpression/FieldExpression/FieldIdentifier\": /*@__PURE__*/tags.function(tags.propertyName),\n                Lifetime: /*@__PURE__*/tags.special(tags.variableName),\n                ScopeIdentifier: tags.namespace,\n                TypeIdentifier: tags.typeName,\n                \"MacroInvocation/Identifier MacroInvocation/ScopedIdentifier/Identifier\": tags.macroName,\n                \"MacroInvocation/TypeIdentifier MacroInvocation/ScopedIdentifier/TypeIdentifier\": tags.macroName,\n                \"\\\"!\\\"\": tags.macroName,\n                UpdateOp: tags.updateOperator,\n                LineComment: tags.lineComment,\n                BlockComment: tags.blockComment,\n                Integer: tags.integer,\n                Float: tags.float,\n                ArithOp: tags.arithmeticOperator,\n                LogicOp: tags.logicOperator,\n                BitOp: tags.bitwiseOperator,\n                CompareOp: tags.compareOperator,\n                \"=\": tags.definitionOperator,\n                \".. ... => ->\": tags.punctuation,\n                \"( )\": tags.paren,\n                \"[ ]\": tags.squareBracket,\n                \"{ }\": tags.brace,\n                \".\": tags.derefOperator,\n                \"&\": tags.operator,\n                \", ; ::\": tags.separator,\n            })\n        ]\n    }),\n    languageData: {\n        commentTokens: { line: \"//\", block: { open: \"/*\", close: \"*/\" } },\n        indentOnInput: /^\\s*(?:\\{|\\})$/\n    }\n});\n/**\nRust language support\n*/\nfunction rust() {\n    return new LanguageSupport(rustLanguage);\n}\n\nexport { rust, rustLanguage };\n"]},"metadata":{},"sourceType":"module"}